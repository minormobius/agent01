/**
 * Transform bakery calculator state into an exchange.recipe.recipe record.
 */

export function calculatorToRecipe({ name, description, state, flours, enrichments, starterFlours, nutrition }) {
  const now = new Date().toISOString();

  // Build ingredient lines from calculator state
  const ingredients = [];

  // Flour blend
  const effectiveGrams = state.usePercentMode
    ? state.blendPercents.map((p) => (p / 100) * state.totalFlourInLoaf)
    : state.blendGrams;

  const totalFlour = effectiveGrams.reduce((a, b) => a + b, 0);

  effectiveGrams.forEach((g, i) => {
    if (g > 0) {
      const pct = totalFlour > 0 ? ((g / totalFlour) * 100).toFixed(0) : 0;
      ingredients.push(`${Math.round(g)}g ${flours[i].name} (${pct}%)`);
    }
  });

  // Water
  if (state.waterGrams > 0) {
    ingredients.push(`${Math.round(state.waterGrams)}g water`);
  }

  // Salt
  if (state.saltGrams > 0) {
    ingredients.push(`${Number(state.saltGrams.toFixed(1))}g salt`);
  }

  // Starter
  if (state.starterEnabled && state.starterGrams > 0) {
    const flourName = starterFlours[state.starterFlourIdx]?.name || "starter";
    ingredients.push(
      `${Math.round(state.starterGrams)}g sourdough starter (${state.starterHydration}% hydration, ${flourName})`
    );
  }

  // Enrichments
  if (state.isEnriched) {
    for (const en of enrichments) {
      const amount = state.enrichAmounts[en.key];
      if (amount > 0) {
        ingredients.push(`${amount}${en.unit} ${en.label.toLowerCase()}`);
      }
    }
  }

  // Build instructions
  const totalAllFlour =
    totalFlour +
    (state.starterEnabled && state.starterGrams > 0
      ? state.starterGrams / (1 + state.starterHydration / 100)
      : 0);

  const hydration =
    totalAllFlour > 0
      ? ((state.waterGrams +
          (state.starterEnabled && state.starterGrams > 0
            ? state.starterGrams -
              state.starterGrams / (1 + state.starterHydration / 100)
            : 0)) /
          totalAllFlour) *
        100
      : 0;

  // Use custom instructions if provided, otherwise generate defaults
  let instructions;
  const customInstructions = (state.recipeInstructions || "").trim();
  if (customInstructions) {
    instructions = customInstructions.split("\n").filter((line) => line.trim());
  } else {
    instructions = [];
    instructions.push(
      `Mix ${Math.round(totalFlour)}g flour blend with ${Math.round(state.waterGrams)}g water. Rest 30 minutes (autolyse).`
    );

    const mixParts = [];
    if (state.saltGrams > 0) mixParts.push("salt");
    if (state.starterEnabled && state.starterGrams > 0) mixParts.push("starter");
    if (state.isEnriched) {
      const enrichNames = enrichments
        .filter((en) => state.enrichAmounts[en.key] > 0)
        .map((en) => en.label.toLowerCase());
      mixParts.push(...enrichNames);
    }
    if (mixParts.length > 0) {
      instructions.push(
        `Add ${mixParts.join(", ")} to the dough. Mix until well incorporated.`
      );
    }

    instructions.push(
      `Bulk ferment at room temperature. Stretch and fold every 30 minutes for the first 2 hours. Target: ${hydration.toFixed(0)}% hydration dough.`
    );

    instructions.push(
      "Pre-shape into a round, bench rest 20 minutes, then final shape. Cold proof in the refrigerator overnight."
    );

    instructions.push(
      "Preheat oven with dutch oven to 500\u00B0F (260\u00B0C). Score the loaf and bake covered 20 minutes, then uncovered at 450\u00B0F (230\u00B0C) for 20-25 minutes until deep golden brown."
    );
  }

  // Build the record â€” required fields only, matching the proven test format
  const record = {
    $type: "exchange.recipe.recipe",
    name: name || "Untitled Bread Recipe",
    text: description || `A ${hydration.toFixed(0)}% hydration bread recipe designed with the Flour Blend Calculator.`,
    ingredients,
    instructions,
    createdAt: now,
    updatedAt: now,
  };

  return record;
}

/**
 * Parse an AT recipe record's ingredient strings back into calculator state.
 * Works with records generated by calculatorToRecipe. For other records,
 * returns what it can parse and leaves the rest at defaults.
 */
export function recipeToCalculator(record, flours, enrichments, starterFlours) {
  const v = record.value || record;
  const ingredients = v.ingredients || [];
  const instructions = v.instructions || [];

  // Start with blank state
  const state = {
    blendPercents: flours.map(() => 0),
    blendGrams: flours.map(() => 0),
    totalFlourInLoaf: 500,
    usePercentMode: false, // load as gram mode since we parse grams
    waterGrams: 0,
    saltGrams: 0,
    isEnriched: false,
    enrichAmounts: { butter: 0, eggs: 0, milk: 0, oliveOil: 0 },
    starterEnabled: false,
    starterGrams: 0,
    starterHydration: 100,
    starterFlourIdx: 0,
    recipeInstructions: instructions.join("\n"),
  };

  for (const line of ingredients) {
    // Match "{number}g {flour name} ({pct}%)"
    const flourMatch = line.match(/^(\d+)g\s+(.+?)\s+\(\d+%\)$/);
    if (flourMatch) {
      const grams = Number(flourMatch[1]);
      const name = flourMatch[2];
      const idx = flours.findIndex((f) => f.name === name);
      if (idx !== -1) {
        state.blendGrams[idx] = grams;
        continue;
      }
    }

    // Match "{number}g water"
    const waterMatch = line.match(/^(\d+)g\s+water$/i);
    if (waterMatch) {
      state.waterGrams = Number(waterMatch[1]);
      continue;
    }

    // Match "{number}g salt"
    const saltMatch = line.match(/^([\d.]+)g\s+salt$/i);
    if (saltMatch) {
      state.saltGrams = Number(saltMatch[1]);
      continue;
    }

    // Match "{number}g sourdough starter ({hydration}% hydration, {flourName})"
    const starterMatch = line.match(/^(\d+)g\s+sourdough starter\s+\((\d+)%\s+hydration,\s+(.+?)\)$/i);
    if (starterMatch) {
      state.starterEnabled = true;
      state.starterGrams = Number(starterMatch[1]);
      state.starterHydration = Number(starterMatch[2]);
      const sfName = starterMatch[3];
      const sfIdx = starterFlours.findIndex((sf) => sf.name === sfName);
      if (sfIdx !== -1) state.starterFlourIdx = sfIdx;
      continue;
    }

    // Match enrichments: "{number}{unit} {label}"
    for (const en of enrichments) {
      const enMatch = line.match(new RegExp(`^(\\d+)${en.unit}\\s+${en.label.toLowerCase()}$`, "i"));
      if (enMatch) {
        state.isEnriched = true;
        state.enrichAmounts[en.key] = Number(enMatch[1]);
        break;
      }
    }
  }

  // Compute totalFlourInLoaf from parsed grams
  const totalGrams = state.blendGrams.reduce((a, b) => a + b, 0);
  if (totalGrams > 0) state.totalFlourInLoaf = totalGrams;

  return { name: v.name || "", state };
}

/**
 * Parse an AT URI into its components.
 */
export function parseAtUri(uri) {
  const match = uri.match(/^at:\/\/([^/]+)\/([^/]+)\/([^/]+)$/);
  if (!match) return null;
  return { repo: match[1], collection: match[2], rkey: match[3] };
}

/**
 * Format an ISO 8601 duration into a human-readable string.
 */
export function formatDuration(dur) {
  if (!dur) return "";
  const m = dur.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
  if (!m) return dur;
  const parts = [];
  if (m[1]) parts.push(`${m[1]}h`);
  if (m[2]) parts.push(`${m[2]}m`);
  if (m[3]) parts.push(`${m[3]}s`);
  return parts.join(" ") || dur;
}
