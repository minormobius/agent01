name: Post to Bluesky

on:
  push:
    paths:
      - 'posts/**.md'

jobs:
  post:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Find new post files
        id: find-posts
        run: |
          POSTS=$(git diff --name-only --diff-filter=AM HEAD~1 HEAD -- 'posts/*.md' || echo "")
          echo "posts=$POSTS" >> $GITHUB_OUTPUT
          if [ -z "$POSTS" ]; then
            echo "No new posts found"
          else
            echo "Found posts: $POSTS"
          fi

      - name: Post to Bluesky
        if: steps.find-posts.outputs.posts != ''
        env:
          BLUESKY_HANDLE: ${{ secrets.BLUESKY_HANDLE }}
          BLUESKY_APP_PASSWORD: ${{ secrets.BLUESKY_APP_PASSWORD }}
        run: |
          set -euo pipefail

          echo "Handle: $BLUESKY_HANDLE"
          echo "Password length: ${#BLUESKY_APP_PASSWORD}"

          if [ -z "$BLUESKY_HANDLE" ] || [ -z "$BLUESKY_APP_PASSWORD" ]; then
            echo "ERROR: Missing BLUESKY_HANDLE or BLUESKY_APP_PASSWORD secrets"
            exit 1
          fi

          # Authenticate
          AUTH_RESPONSE=$(curl -s -X POST "https://bsky.social/xrpc/com.atproto.server.createSession" \
            -H "Content-Type: application/json" \
            -d "{\"identifier\": \"$BLUESKY_HANDLE\", \"password\": \"$BLUESKY_APP_PASSWORD\"}")

          DID=$(echo "$AUTH_RESPONSE" | jq -r '.did // empty')
          ACCESS_TOKEN=$(echo "$AUTH_RESPONSE" | jq -r '.accessJwt // empty')

          if [ -z "$DID" ] || [ -z "$ACCESS_TOKEN" ]; then
            echo "Authentication failed. Response:"
            echo "$AUTH_RESPONSE" | jq .
            echo ""
            echo "Check that BLUESKY_HANDLE is set to your full handle (e.g. minomobi.bsky.social)"
            echo "and BLUESKY_APP_PASSWORD is a valid app password from Settings > App Passwords"
            exit 1
          fi

          echo "Authenticated as $DID"

          # Create rich text parser (markdown links → Bluesky facets)
          cat > /tmp/parse_richtext.py << 'PYEOF'
          import sys, json, re

          text = sys.stdin.read().strip()
          facets = []

          # Pass 1: markdown links [text](url) → display text + link facet
          clean = ""
          last = 0
          for m in re.finditer(r'\[([^\]]+)\]\(([^)]+)\)', text):
              clean += text[last:m.start()]
              display, url = m.group(1), m.group(2)
              byte_start = len(clean.encode('utf-8'))
              clean += display
              byte_end = len(clean.encode('utf-8'))
              if not url.startswith(('http://', 'https://')):
                  url = 'https://' + url
              facets.append({
                  "index": {"byteStart": byte_start, "byteEnd": byte_end},
                  "features": [{"$type": "app.bsky.richtext.facet#link", "uri": url}]
              })
              last = m.end()
          clean += text[last:]

          # Pass 2: bare https:// URLs in clean text
          for m in re.finditer(r'https?://[^\s\)\]]+', clean):
              url = m.group(0).rstrip('.,;:!?')
              bs = len(clean[:m.start()].encode('utf-8'))
              be = bs + len(url.encode('utf-8'))
              if not any(f['index']['byteStart'] <= bs and f['index']['byteEnd'] >= be for f in facets):
                  facets.append({
                      "index": {"byteStart": bs, "byteEnd": be},
                      "features": [{"$type": "app.bsky.richtext.facet#link", "uri": url}]
                  })

          # Pass 3: bare domains (minomobi.com, etc.)
          for m in re.finditer(r'(?<![/\w@])([a-zA-Z0-9][-a-zA-Z0-9]*\.(?:com|org|net|io|co|dev|social|app)\b[/\w.-]*)', clean):
              dt = m.group(0).rstrip('.,;:!?')
              bs = len(clean[:m.start()].encode('utf-8'))
              be = bs + len(dt.encode('utf-8'))
              if not any(f['index']['byteStart'] <= bs and f['index']['byteEnd'] >= be for f in facets):
                  facets.append({
                      "index": {"byteStart": bs, "byteEnd": be},
                      "features": [{"$type": "app.bsky.richtext.facet#link", "uri": "https://" + dt}]
                  })

          facets.sort(key=lambda f: f['index']['byteStart'])
          json.dump({"text": clean, "facets": facets}, sys.stdout)
          PYEOF

          for POST_FILE in ${{ steps.find-posts.outputs.posts }}; do
            echo "Processing: $POST_FILE"

            # Parse the markdown file into posts
            # Format: --- / title / --- / post1 / --- / post2 / --- / ...
            # We skip section 0 (before first ---) and section 1 (title between first two ---)
            SECTION=0
            CURRENT_POST=""
            THREAD_ROOT_URI=""
            THREAD_ROOT_CID=""
            PARENT_URI=""
            PARENT_CID=""

            MAX_POSTS=9
            POST_COUNT=0

            post_to_bluesky() {
              local RAW_TEXT="$1"

              # Enforce max thread length
              if [ "$POST_COUNT" -ge "$MAX_POSTS" ]; then
                echo "Reached max thread length ($MAX_POSTS posts), stopping"
                return 2
              fi

              # Parse rich text: strip markdown links, build facets
              local PARSED
              PARSED=$(printf '%s' "$RAW_TEXT" | python3 /tmp/parse_richtext.py)
              local TEXT FACETS_JSON
              TEXT=$(echo "$PARSED" | jq -r '.text')
              FACETS_JSON=$(echo "$PARSED" | jq -c '.facets')

              # Check character limit on display text
              local CHAR_COUNT=${#TEXT}
              if [ "$CHAR_COUNT" -gt 300 ]; then
                echo "WARNING: Post is $CHAR_COUNT chars (limit 300), truncating"
                TEXT="${TEXT:0:297}..."
                # Drop facets past truncation point
                local BYTE_LIMIT
                BYTE_LIMIT=$(printf '%s' "$TEXT" | wc -c)
                FACETS_JSON=$(echo "$FACETS_JSON" | jq -c --argjson lim "$BYTE_LIMIT" '[.[] | select(.index.byteEnd <= $lim)]')
              fi

              local NOW
              NOW=$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")

              # Build the record with optional facets and reply
              local RECORD
              RECORD=$(jq -n \
                --arg text "$TEXT" \
                --arg now "$NOW" \
                --argjson facets "$FACETS_JSON" \
                '{
                  "$type": "app.bsky.feed.post",
                  text: $text,
                  createdAt: $now
                } + (if ($facets | length) > 0 then {facets: $facets} else {} end)')

              if [ -n "$THREAD_ROOT_URI" ]; then
                RECORD=$(echo "$RECORD" | jq -c \
                  --arg root_uri "$THREAD_ROOT_URI" \
                  --arg root_cid "$THREAD_ROOT_CID" \
                  --arg parent_uri "$PARENT_URI" \
                  --arg parent_cid "$PARENT_CID" \
                  '. + {
                    reply: {
                      root: { uri: $root_uri, cid: $root_cid },
                      parent: { uri: $parent_uri, cid: $parent_cid }
                    }
                  }')
              fi

              local POST_JSON
              POST_JSON=$(jq -n \
                --arg did "$DID" \
                --argjson record "$RECORD" \
                '{
                  repo: $did,
                  collection: "app.bsky.feed.post",
                  record: $record
                }')

              local RESPONSE
              RESPONSE=$(curl -s -X POST "https://bsky.social/xrpc/com.atproto.repo.createRecord" \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer $ACCESS_TOKEN" \
                -d "$POST_JSON")

              local NEW_URI NEW_CID
              NEW_URI=$(echo "$RESPONSE" | jq -r '.uri // empty')
              NEW_CID=$(echo "$RESPONSE" | jq -r '.cid // empty')

              if [ -z "$NEW_URI" ]; then
                echo "Failed to post. Response:"
                echo "$RESPONSE" | jq .
                echo "Skipping this post and continuing thread"
                return 1
              fi

              local FACET_COUNT
              FACET_COUNT=$(echo "$FACETS_JSON" | jq 'length')
              echo "Posted ($((POST_COUNT + 1))/$MAX_POSTS, $FACET_COUNT links): $NEW_URI"

              if [ -z "$THREAD_ROOT_URI" ]; then
                THREAD_ROOT_URI="$NEW_URI"
                THREAD_ROOT_CID="$NEW_CID"
              fi
              PARENT_URI="$NEW_URI"
              PARENT_CID="$NEW_CID"
              POST_COUNT=$((POST_COUNT + 1))

              sleep 2
            }

            while IFS= read -r line; do
              if [ "$line" = "---" ]; then
                # On hitting a delimiter, post content if we're past the title (section >= 2)
                if [ "$SECTION" -ge 2 ]; then
                  TRIMMED=$(echo "$CURRENT_POST" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
                  if [ -n "$TRIMMED" ]; then
                    post_to_bluesky "$TRIMMED" || {
                      RC=$?
                      if [ "$RC" -eq 2 ]; then break; fi
                      echo "Post failed (rc=$RC), continuing..."
                    }
                  fi
                fi
                SECTION=$((SECTION + 1))
                CURRENT_POST=""
                continue
              fi

              # Accumulate lines for sections >= 2 (skip title in section 1)
              if [ "$SECTION" -ge 2 ]; then
                if [ -z "$CURRENT_POST" ]; then
                  CURRENT_POST="$line"
                else
                  CURRENT_POST="${CURRENT_POST}"$'\n'"${line}"
                fi
              fi
            done < "$POST_FILE"

            # Post any remaining content after the last --- delimiter
            if [ "$POST_COUNT" -lt "$MAX_POSTS" ] && [ "$SECTION" -ge 2 ] && [ -n "$(echo "$CURRENT_POST" | tr -d '[:space:]')" ]; then
              TRIMMED=$(echo "$CURRENT_POST" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
              post_to_bluesky "$TRIMMED" || echo "Final post failed, thread still posted"
            fi

            echo "Thread complete for $POST_FILE"
          done

          echo "All posts processed successfully"
