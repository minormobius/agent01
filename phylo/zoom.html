<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>phylo — zoom — minomobi</title>
<style>
  * { margin: 0; box-sizing: border-box; }
  body { background: #0a0a0a; overflow: hidden; font-family: monospace; }
  canvas { display: block; cursor: grab; }
  canvas.dragging { cursor: grabbing; }
  #hud {
    position: fixed; top: 0; left: 0; right: 0;
    padding: 8px 12px; background: rgba(10,10,10,.9);
    color: #666; font: 12px monospace; z-index: 10;
    display: flex; align-items: center; gap: 12px;
    border-bottom: 1px solid #1a1a1a;
    user-select: none;
  }
  #hud a { color: #555; text-decoration: none; }
  #hud a:hover { color: #aaa; }
  #status { color: #555; }
  #breadcrumb { color: #555; margin-left: auto; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  #breadcrumb span { cursor: pointer; }
  #breadcrumb span:hover { color: #aaa; }
  #hover-info {
    position: fixed; bottom: 0; left: 0; right: 0;
    padding: 6px 12px; background: rgba(10,10,10,.92);
    color: #888; font: 12px monospace; z-index: 10;
    border-top: 1px solid #1a1a1a;
    opacity: 0; transition: opacity .15s;
    user-select: none;
  }
  #hover-info.visible { opacity: 1; }
  #hover-info .h-name { color: #ccc; }
  #hover-info .h-rank { color: #666; }
  #hover-info .h-tips { color: #555; }
</style>
</head>
<body>
<div id="hud">
  <a href="index.html">&larr; text tree</a>
  <span style="color:#222">|</span>
  <span style="color:#777">phylo zoom</span>
  <span id="status">loading&hellip;</span>
  <span id="breadcrumb"></span>
</div>
<div id="hover-info">
  <span class="h-name"></span>
  <span class="h-rank"></span>
  <span class="h-tips"></span>
</div>
<canvas id="c"></canvas>
<script>
// ── Config ──────────────────────────────────────────────────────────
const OTT_ROOT = 913935; // Primates
const API = "https://api.opentreeoflife.org/v3";

// ── Canvas ──────────────────────────────────────────────────────────
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
let W, H, dpr;

function resize() {
  dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + "px";
  canvas.style.height = H + "px";
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  scheduleDraw();
}
window.addEventListener("resize", resize);

// ── Camera ──────────────────────────────────────────────────────────
const cam = { x: 0, y: 0, scale: 1 };

function w2s(wx, wy) {
  return [
    (wx - cam.x) * cam.scale + W / 2,
    (wy - cam.y) * cam.scale + H / 2
  ];
}
function s2w(sx, sy) {
  return [
    (sx - W / 2) / cam.scale + cam.x,
    (sy - H / 2) / cam.scale + cam.y
  ];
}

// ── Data ────────────────────────────────────────────────────────────
let root = null;
const flat = []; // flat node list for hit-testing

async function fetchTree(ottId) {
  const r = await fetch(`${API}/tree_of_life/subtree`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ node_id: `ott${ottId}`, format: "arguson", height_limit: -1 })
  });
  return (await r.json()).arguson;
}

// ── Layout ──────────────────────────────────────────────────────────
// Radial fractal: each node → (x, y, r) in world space.
// Root at origin, radius 1. Children fan outward.

function layoutTree(node, cx, cy, radius, aStart, aSweep, depth, parent) {
  const tax = node.taxon || {};
  node._x = cx;
  node._y = cy;
  node._r = radius;
  node._depth = depth;
  node._name = tax.name || "";
  node._rank = tax.rank || "";
  node._ottId = tax.ott_id;
  node._tips = node.num_tips || 0;
  node._parent = parent;
  flat.push(node);

  const kids = node.children;
  if (!kids || kids.length === 0) { node._leaf = true; return; }
  node._leaf = false;

  // Angle weights: use sqrt(tips) to dampen large/small disparity
  const weights = kids.map(c => Math.sqrt(c.num_tips || 1));
  const totalW = weights.reduce((a, b) => a + b, 0);

  // Placement distance: children sit at this fraction of parent radius from center
  const dist = radius * 0.58;

  let angle = aStart;
  for (let i = 0; i < kids.length; i++) {
    const frac = weights[i] / totalW;
    const childSweep = aSweep * frac;
    const midAngle = angle + childSweep / 2;

    // Child radius: constrained by sector width AND parent scale
    const sectorHalf = dist * Math.sin(Math.min(childSweep / 2, Math.PI * 0.45));
    const childR = Math.min(sectorHalf * 0.88, radius * 0.48);

    const childCx = cx + dist * Math.cos(midAngle);
    const childCy = cy + dist * Math.sin(midAngle);

    layoutTree(kids[i], childCx, childCy, Math.max(childR, radius * 0.01),
               midAngle - childSweep / 2, childSweep, depth + 1, node);
    angle += childSweep;
  }
}

// ── Rendering ───────────────────────────────────────────────────────
let drawId = 0;
function scheduleDraw() {
  cancelAnimationFrame(drawId);
  drawId = requestAnimationFrame(draw);
}

// Depth-based colors (hue shifts slightly with depth)
function nodeColor(depth, leaf) {
  if (leaf) return `hsl(${140 + depth * 3}, 40%, ${38 + Math.min(depth, 10) * 2}%)`;
  return `hsl(${200 + depth * 5}, 15%, ${40 + Math.min(depth, 8) * 2}%)`;
}

function branchColor(depth) {
  const l = 18 + Math.min(depth, 12) * 1.5;
  return `hsl(200, 8%, ${l}%)`;
}

let nodesDrawn = 0;

function draw() {
  if (!root) return;
  ctx.fillStyle = "#0a0a0a";
  ctx.fillRect(0, 0, W, H);
  nodesDrawn = 0;
  drawSubtree(root);
}

function drawSubtree(node) {
  const [sx, sy] = w2s(node._x, node._y);
  const sr = node._r * cam.scale;

  // Cull: off-screen
  if (sx + sr < -20 || sx - sr > W + 20) return;
  if (sy + sr < -20 || sy - sr > H + 20) return;
  // Cull: too small
  if (sr < 1.2) return;

  nodesDrawn++;
  const kids = node.children;

  // ── Branches ──
  if (kids && kids.length > 0) {
    for (const child of kids) {
      const csr = child._r * cam.scale;
      if (csr < 0.5) continue;
      const [csx, csy] = w2s(child._x, child._y);
      // Quick off-screen check for the child endpoint
      if (csx < -20 || csx > W + 20 || csy < -20 || csy > H + 20) {
        if (csr < 20) continue; // skip small off-screen children entirely
      }
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      // Quadratic bezier curving slightly toward center
      const mx = (sx + csx) / 2;
      const my = (sy + csy) / 2;
      const perpX = -(csy - sy) * 0.08;
      const perpY =  (csx - sx) * 0.08;
      ctx.quadraticCurveTo(mx + perpX, my + perpY, csx, csy);
      ctx.strokeStyle = branchColor(node._depth);
      ctx.lineWidth = Math.max(0.4, Math.min(sr * 0.015, 1.8));
      ctx.stroke();
    }
    for (const child of kids) drawSubtree(child);
  }

  // ── Node dot ──
  const dotR = node._leaf
    ? Math.max(1.2, Math.min(sr * 0.06, 4))
    : Math.max(1.5, Math.min(sr * 0.04, 5));

  ctx.fillStyle = nodeColor(node._depth, node._leaf);
  ctx.beginPath();
  ctx.arc(sx, sy, dotR, 0, Math.PI * 2);
  ctx.fill();

  // ── Highlight hovered ──
  if (node === hoveredNode) {
    ctx.strokeStyle = "#8bf";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(sx, sy, dotR + 3, 0, Math.PI * 2);
    ctx.stroke();
  }

  // ── Labels ──
  if (sr > 28 && node._name) {
    const fontSize = Math.max(8, Math.min(sr * 0.055, 13));
    ctx.font = `${fontSize}px monospace`;
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillStyle = sr > 70
      ? `hsla(0, 0%, ${75 + Math.min(node._depth, 5) * 2}%, .9)`
      : `hsla(0, 0%, 50%, ${Math.min(1, (sr - 28) / 40)})`;
    ctx.fillText(node._name, sx, sy + dotR + 2);

    if (sr > 90 && node._rank && node._rank !== "no rank") {
      ctx.fillStyle = `hsla(0, 0%, 40%, .7)`;
      ctx.font = `${Math.max(7, fontSize * 0.72)}px monospace`;
      ctx.fillText(node._rank, sx, sy + dotR + fontSize + 3);
    }
  }
}

// ── Interaction ─────────────────────────────────────────────────────
let dragging = false;
let dragStart = null;
let dragCamStart = null;
let hoveredNode = null;

canvas.addEventListener("mousedown", e => {
  dragging = true;
  dragStart = { x: e.clientX, y: e.clientY };
  dragCamStart = { x: cam.x, y: cam.y };
  canvas.classList.add("dragging");
});

window.addEventListener("mousemove", e => {
  if (dragging) {
    cam.x = dragCamStart.x - (e.clientX - dragStart.x) / cam.scale;
    cam.y = dragCamStart.y - (e.clientY - dragStart.y) / cam.scale;
    scheduleDraw();
  } else if (root) {
    updateHover(e.clientX, e.clientY);
  }
});

window.addEventListener("mouseup", () => {
  dragging = false;
  canvas.classList.remove("dragging");
});

canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const zoomFactor = e.deltaY > 0 ? 1.12 : 1 / 1.12;
  const [wx, wy] = s2w(e.clientX, e.clientY);
  cam.scale /= zoomFactor;
  // Keep world point under cursor fixed
  cam.x = wx - (e.clientX - W / 2) / cam.scale;
  cam.y = wy - (e.clientY - H / 2) / cam.scale;
  scheduleDraw();
}, { passive: false });

canvas.addEventListener("dblclick", e => {
  const hit = hitTest(e.clientX, e.clientY);
  if (hit) flyTo(hit);
});

// Touch support
let lastTouchDist = 0;
let lastTouchMid = null;
canvas.addEventListener("touchstart", e => {
  if (e.touches.length === 1) {
    dragging = true;
    dragStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    dragCamStart = { x: cam.x, y: cam.y };
  } else if (e.touches.length === 2) {
    dragging = false;
    const dx = e.touches[1].clientX - e.touches[0].clientX;
    const dy = e.touches[1].clientY - e.touches[0].clientY;
    lastTouchDist = Math.sqrt(dx * dx + dy * dy);
    lastTouchMid = {
      x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
      y: (e.touches[0].clientY + e.touches[1].clientY) / 2
    };
  }
  e.preventDefault();
}, { passive: false });

canvas.addEventListener("touchmove", e => {
  if (e.touches.length === 1 && dragging) {
    cam.x = dragCamStart.x - (e.touches[0].clientX - dragStart.x) / cam.scale;
    cam.y = dragCamStart.y - (e.touches[0].clientY - dragStart.y) / cam.scale;
    scheduleDraw();
  } else if (e.touches.length === 2) {
    const dx = e.touches[1].clientX - e.touches[0].clientX;
    const dy = e.touches[1].clientY - e.touches[0].clientY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const mid = {
      x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
      y: (e.touches[0].clientY + e.touches[1].clientY) / 2
    };
    if (lastTouchDist > 0) {
      const zoomFactor = lastTouchDist / dist;
      const [wx, wy] = s2w(mid.x, mid.y);
      cam.scale /= zoomFactor;
      cam.x = wx - (mid.x - W / 2) / cam.scale;
      cam.y = wy - (mid.y - H / 2) / cam.scale;
      scheduleDraw();
    }
    lastTouchDist = dist;
    lastTouchMid = mid;
  }
  e.preventDefault();
}, { passive: false });

canvas.addEventListener("touchend", e => {
  dragging = false;
  lastTouchDist = 0;
  lastTouchMid = null;
});

// ── Hit testing ─────────────────────────────────────────────────────
function hitTest(sx, sy) {
  const [wx, wy] = s2w(sx, sy);
  let best = null;
  let bestR = Infinity;
  for (const n of flat) {
    if (n._r * cam.scale < 1.2) continue; // not visible
    const dx = wx - n._x;
    const dy = wy - n._y;
    const d = Math.sqrt(dx * dx + dy * dy);
    // Hit within 15% of node radius, prefer smaller (more specific) nodes
    if (d < n._r * 0.18 && n._r < bestR) {
      bestR = n._r;
      best = n;
    }
  }
  return best;
}

const hoverEl = document.getElementById("hover-info");
const hName = hoverEl.querySelector(".h-name");
const hRank = hoverEl.querySelector(".h-rank");
const hTips = hoverEl.querySelector(".h-tips");

function updateHover(sx, sy) {
  const hit = hitTest(sx, sy);
  if (hit !== hoveredNode) {
    hoveredNode = hit;
    scheduleDraw();
  }
  if (hit && hit._name) {
    hoverEl.classList.add("visible");
    hName.textContent = hit._name;
    hRank.textContent = hit._rank && hit._rank !== "no rank" ? ` \u00b7 ${hit._rank}` : "";
    hTips.textContent = hit._tips > 0 ? ` \u00b7 ${hit._tips} species` : "";
    updateBreadcrumb(hit);
  } else {
    hoverEl.classList.remove("visible");
  }
}

// ── Breadcrumb ──────────────────────────────────────────────────────
const breadcrumbEl = document.getElementById("breadcrumb");

function updateBreadcrumb(node) {
  const path = [];
  let n = node;
  while (n) {
    if (n._name) path.unshift(n);
    n = n._parent;
  }
  breadcrumbEl.innerHTML = path.map(p =>
    `<span data-ott="${p._ottId || ""}">${p._name}</span>`
  ).join(" &rsaquo; ");

  for (const span of breadcrumbEl.querySelectorAll("span")) {
    span.addEventListener("click", () => {
      const ott = span.dataset.ott;
      const target = flat.find(n => String(n._ottId) === ott);
      if (target) flyTo(target);
    });
  }
}

// ── Animation ───────────────────────────────────────────────────────
function flyTo(node, duration) {
  duration = duration || 500;
  const targetScale = Math.min(W, H) / (node._r * 2.8);
  const sx = cam.x, sy = cam.y, ss = cam.scale;
  const tx = node._x, ty = node._y, ts = targetScale;
  const t0 = performance.now();

  function step(now) {
    let t = Math.min(1, (now - t0) / duration);
    t = 1 - Math.pow(1 - t, 3); // ease-out cubic
    cam.x = sx + (tx - sx) * t;
    cam.y = sy + (ty - sy) * t;
    cam.scale = ss * Math.pow(ts / ss, t);
    scheduleDraw();
    if (t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

// ── Init ────────────────────────────────────────────────────────────
(async () => {
  const status = document.getElementById("status");
  resize();

  try {
    status.textContent = "fetching primates\u2026";
    const tree = await fetchTree(OTT_ROOT);
    status.textContent = "laying out\u2026";
    root = tree;

    layoutTree(root, 0, 0, 1, 0, Math.PI * 2, 0, null);

    // Initial camera: fit root
    cam.scale = Math.min(W, H) * 0.38;

    status.textContent = `${flat.length} nodes \u00b7 scroll to zoom \u00b7 drag to pan \u00b7 double-click to focus`;
    scheduleDraw();
  } catch (e) {
    status.textContent = `error: ${e.message}`;
  }
})();
</script>
</body>
</html>
