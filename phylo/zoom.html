<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>phylo — zoom — minomobi</title>
<style>
  * { margin: 0; box-sizing: border-box; }
  body { background: #0a0a0a; overflow: hidden; font-family: monospace; }
  canvas { display: block; cursor: grab; }
  canvas.dragging { cursor: grabbing; }
  #hud {
    position: fixed; top: 0; left: 0; right: 0;
    padding: 8px 12px; background: rgba(10,10,10,.9);
    color: #666; font: 12px monospace; z-index: 10;
    display: flex; align-items: center; gap: 12px;
    border-bottom: 1px solid #1a1a1a;
    user-select: none;
  }
  #hud a { color: #555; text-decoration: none; }
  #hud a:hover { color: #aaa; }
  #status { color: #555; }
  #breadcrumb { color: #555; margin-left: auto; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  #breadcrumb span { cursor: pointer; }
  #breadcrumb span:hover { color: #aaa; }
  #hover-info {
    position: fixed; bottom: 0; left: 0; right: 0;
    padding: 6px 12px; background: rgba(10,10,10,.92);
    color: #888; font: 12px monospace; z-index: 10;
    border-top: 1px solid #1a1a1a;
    opacity: 0; transition: opacity .15s;
    user-select: none;
  }
  #hover-info.visible { opacity: 1; }
  #hover-info .h-name { color: #ccc; }
  #hover-info .h-rank { color: #666; }
  #hover-info .h-tips { color: #555; }

  /* info panel */
  #info-panel {
    position: fixed; top: 30px; right: 0; bottom: 0;
    width: 0; overflow: hidden; transition: width .2s;
    border-left: 1px solid #222; background: rgba(10,10,10,.96);
    z-index: 20; font: 13px/1.6 monospace; color: #ccc;
  }
  #info-panel.open { width: 320px; }
  #info-inner {
    width: 320px; padding: 1em; overflow-y: auto; height: 100%;
  }
  #info-panel h2 { font-size: 1em; color: #ddd; margin-bottom: .2em; font-weight: normal; }
  #info-panel .info-rank { color: #777; font-size: .85em; margin-bottom: .8em; }
  #info-panel .info-section { margin-bottom: .8em; }
  #info-panel .info-label { color: #666; font-size: .8em; text-transform: uppercase; letter-spacing: .05em; margin-bottom: .3em; }
  #info-panel a {
    color: #8bf; text-decoration: none; display: block; padding: 3px 0;
    border-bottom: 1px solid #1a1a1a;
  }
  #info-panel a:hover { color: #adf; }
  #info-panel a::before { content: "↗ "; color: #444; }
  #info-panel .info-loading { color: #555; }
  #info-panel .info-close {
    cursor: pointer; color: #555; float: right; font-size: 1.2em; line-height: 1;
  }
  #info-panel .info-close:hover { color: #fff; }
  #info-panel .info-flags { color: #665; font-size: .8em; margin-top: .3em; }
  #info-panel .info-synonyms { color: #666; font-size: .85em; }
  #info-panel .info-synonyms span { color: #888; }
  #info-panel .iucn-badge {
    display: inline-block; font-size: .75em; padding: 1px 5px; border-radius: 3px;
    color: #111; font-weight: bold; margin-left: .4em; vertical-align: middle;
  }
  .iucn-LC { background: #4caf50; } .iucn-NT { background: #8bc34a; }
  .iucn-VU { background: #ff9800; } .iucn-EN { background: #f44336; }
  .iucn-CR { background: #b71c1c; color: #fff; } .iucn-EW { background: #555; color: #fff; }
  .iucn-EX { background: #000; color: #666; } .iucn-DD { background: #888; }
</style>
</head>
<body>
<div id="hud">
  <a href="index.html">&larr; text tree</a>
  <span style="color:#222">|</span>
  <span style="color:#777">phylo zoom</span>
  <span id="status">loading&hellip;</span>
  <span id="breadcrumb"></span>
</div>
<div id="hover-info">
  <span class="h-name"></span>
  <span class="h-rank"></span>
  <span class="h-tips"></span>
</div>
<div id="info-panel"><div id="info-inner"></div></div>
<canvas id="c"></canvas>
<script>
// ── Config ──────────────────────────────────────────────────────────
const OTT_ROOT = 913935; // Primates
const API = "https://api.opentreeoflife.org/v3";

// ── Canvas ──────────────────────────────────────────────────────────
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
let W, H, dpr;

function resize() {
  dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + "px";
  canvas.style.height = H + "px";
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  scheduleDraw();
}
window.addEventListener("resize", resize);

// ── Camera ──────────────────────────────────────────────────────────
const cam = { x: 0, y: 0, scale: 1 };

function w2s(wx, wy) {
  return [
    (wx - cam.x) * cam.scale + W / 2,
    (wy - cam.y) * cam.scale + H / 2
  ];
}
function s2w(sx, sy) {
  return [
    (sx - W / 2) / cam.scale + cam.x,
    (sy - H / 2) / cam.scale + cam.y
  ];
}

// ── Data ────────────────────────────────────────────────────────────
let root = null;
const flat = []; // flat node list for hit-testing

async function fetchTree(ottId) {
  const r = await fetch(`${API}/tree_of_life/subtree`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ node_id: `ott${ottId}`, format: "arguson", height_limit: -1 })
  });
  return (await r.json()).arguson;
}

// ── Layout ──────────────────────────────────────────────────────────
// Radial fractal: each node → (x, y, r) in world space.
// Root at origin, radius 1. Children fan outward.

function layoutTree(node, cx, cy, radius, aStart, aSweep, depth, parent) {
  const tax = node.taxon || {};
  node._x = cx;
  node._y = cy;
  node._r = radius;
  node._depth = depth;
  node._name = tax.name || "";
  node._rank = tax.rank || "";
  node._ottId = tax.ott_id;
  node._tips = node.num_tips || 0;
  node._parent = parent;
  flat.push(node);

  const kids = node.children;
  if (!kids || kids.length === 0) { node._leaf = true; return; }
  node._leaf = false;

  // Angle weights: use sqrt(tips) to dampen large/small disparity
  const weights = kids.map(c => Math.sqrt(c.num_tips || 1));
  const totalW = weights.reduce((a, b) => a + b, 0);

  // Placement distance: children sit at this fraction of parent radius from center
  const dist = radius * 0.58;

  let angle = aStart;
  for (let i = 0; i < kids.length; i++) {
    const frac = weights[i] / totalW;
    const childSweep = aSweep * frac;
    const midAngle = angle + childSweep / 2;

    // Child radius: constrained by sector width AND parent scale
    const sectorHalf = dist * Math.sin(Math.min(childSweep / 2, Math.PI * 0.45));
    const childR = Math.min(sectorHalf * 0.88, radius * 0.48);

    const childCx = cx + dist * Math.cos(midAngle);
    const childCy = cy + dist * Math.sin(midAngle);

    layoutTree(kids[i], childCx, childCy, Math.max(childR, radius * 0.01),
               midAngle - childSweep / 2, childSweep, depth + 1, node);
    angle += childSweep;
  }
}

// ── Rendering ───────────────────────────────────────────────────────
let drawId = 0;
function scheduleDraw() {
  cancelAnimationFrame(drawId);
  drawId = requestAnimationFrame(draw);
}

// Depth-based colors (hue shifts slightly with depth)
function nodeColor(depth, leaf) {
  if (leaf) return `hsl(${140 + depth * 3}, 40%, ${38 + Math.min(depth, 10) * 2}%)`;
  return `hsl(${200 + depth * 5}, 15%, ${40 + Math.min(depth, 8) * 2}%)`;
}

function branchColor(depth) {
  const l = 18 + Math.min(depth, 12) * 1.5;
  return `hsl(200, 8%, ${l}%)`;
}

let nodesDrawn = 0;

function draw() {
  if (!root) return;
  ctx.fillStyle = "#0a0a0a";
  ctx.fillRect(0, 0, W, H);
  nodesDrawn = 0;
  drawSubtree(root);
}

function drawSubtree(node) {
  const [sx, sy] = w2s(node._x, node._y);
  const sr = node._r * cam.scale;

  // Cull: off-screen
  if (sx + sr < -20 || sx - sr > W + 20) return;
  if (sy + sr < -20 || sy - sr > H + 20) return;
  // Cull: too small
  if (sr < 1.2) return;

  nodesDrawn++;
  const kids = node.children;

  // ── Branches ──
  if (kids && kids.length > 0) {
    for (const child of kids) {
      const csr = child._r * cam.scale;
      if (csr < 0.5) continue;
      const [csx, csy] = w2s(child._x, child._y);
      // Quick off-screen check for the child endpoint
      if (csx < -20 || csx > W + 20 || csy < -20 || csy > H + 20) {
        if (csr < 20) continue; // skip small off-screen children entirely
      }
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      // Quadratic bezier curving slightly toward center
      const mx = (sx + csx) / 2;
      const my = (sy + csy) / 2;
      const perpX = -(csy - sy) * 0.08;
      const perpY =  (csx - sx) * 0.08;
      ctx.quadraticCurveTo(mx + perpX, my + perpY, csx, csy);
      ctx.strokeStyle = branchColor(node._depth);
      ctx.lineWidth = Math.max(0.4, Math.min(sr * 0.015, 1.8));
      ctx.stroke();
    }
    for (const child of kids) drawSubtree(child);
  }

  // ── Node dot ──
  const dotR = node._leaf
    ? Math.max(1.2, Math.min(sr * 0.06, 4))
    : Math.max(1.5, Math.min(sr * 0.04, 5));

  ctx.fillStyle = nodeColor(node._depth, node._leaf);
  ctx.beginPath();
  ctx.arc(sx, sy, dotR, 0, Math.PI * 2);
  ctx.fill();

  // ── Highlight selected ──
  if (node === selectedNode) {
    ctx.strokeStyle = "#f92";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(sx, sy, dotR + 4, 0, Math.PI * 2);
    ctx.stroke();
    ctx.strokeStyle = "rgba(255,153,34,.25)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(sx, sy, dotR + 8, 0, Math.PI * 2);
    ctx.stroke();
  }

  // ── Highlight hovered ──
  if (node === hoveredNode && node !== selectedNode) {
    ctx.strokeStyle = "#8bf";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(sx, sy, dotR + 3, 0, Math.PI * 2);
    ctx.stroke();
  }

  // ── Labels ──
  if (sr > 28 && node._name) {
    const fontSize = Math.max(8, Math.min(sr * 0.055, 13));
    ctx.font = `${fontSize}px monospace`;
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillStyle = sr > 70
      ? `hsla(0, 0%, ${75 + Math.min(node._depth, 5) * 2}%, .9)`
      : `hsla(0, 0%, 50%, ${Math.min(1, (sr - 28) / 40)})`;
    ctx.fillText(node._name, sx, sy + dotR + 2);

    if (sr > 90 && node._rank && node._rank !== "no rank") {
      ctx.fillStyle = `hsla(0, 0%, 40%, .7)`;
      ctx.font = `${Math.max(7, fontSize * 0.72)}px monospace`;
      ctx.fillText(node._rank, sx, sy + dotR + fontSize + 3);
    }
  }
}

// ── Interaction ─────────────────────────────────────────────────────
let dragging = false;
let dragStart = null;
let dragCamStart = null;
let hoveredNode = null;
let selectedNode = null;

let dragMoved = false;

canvas.addEventListener("mousedown", e => {
  dragging = true;
  dragMoved = false;
  dragStart = { x: e.clientX, y: e.clientY };
  dragCamStart = { x: cam.x, y: cam.y };
  canvas.classList.add("dragging");
});

window.addEventListener("mousemove", e => {
  if (dragging) {
    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;
    if (Math.abs(dx) > 3 || Math.abs(dy) > 3) dragMoved = true;
    cam.x = dragCamStart.x - dx / cam.scale;
    cam.y = dragCamStart.y - dy / cam.scale;
    scheduleDraw();
  } else if (root) {
    updateHover(e.clientX, e.clientY);
  }
});

window.addEventListener("mouseup", e => {
  if (!dragMoved && root) {
    const hit = hitTest(e.clientX, e.clientY);
    selectNode(hit);
  }
  dragging = false;
  canvas.classList.remove("dragging");
});

canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const zoomFactor = e.deltaY > 0 ? 1.05 : 1 / 1.05;
  const [wx, wy] = s2w(e.clientX, e.clientY);
  cam.scale /= zoomFactor;
  // Keep world point under cursor fixed
  cam.x = wx - (e.clientX - W / 2) / cam.scale;
  cam.y = wy - (e.clientY - H / 2) / cam.scale;
  scheduleDraw();
}, { passive: false });

canvas.addEventListener("dblclick", e => {
  const hit = hitTest(e.clientX, e.clientY);
  if (hit) flyTo(hit);
});

// Touch support
let lastTouchDist = 0;
let lastTouchMid = null;
let touchMoved = false;
canvas.addEventListener("touchstart", e => {
  if (e.touches.length === 1) {
    dragging = true;
    touchMoved = false;
    dragStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    dragCamStart = { x: cam.x, y: cam.y };
  } else if (e.touches.length === 2) {
    dragging = false;
    const dx = e.touches[1].clientX - e.touches[0].clientX;
    const dy = e.touches[1].clientY - e.touches[0].clientY;
    lastTouchDist = Math.sqrt(dx * dx + dy * dy);
    lastTouchMid = {
      x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
      y: (e.touches[0].clientY + e.touches[1].clientY) / 2
    };
  }
  e.preventDefault();
}, { passive: false });

canvas.addEventListener("touchmove", e => {
  if (e.touches.length === 1 && dragging) {
    const dx = e.touches[0].clientX - dragStart.x;
    const dy = e.touches[0].clientY - dragStart.y;
    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) touchMoved = true;
    cam.x = dragCamStart.x - dx / cam.scale;
    cam.y = dragCamStart.y - dy / cam.scale;
    scheduleDraw();
  } else if (e.touches.length === 2) {
    const dx = e.touches[1].clientX - e.touches[0].clientX;
    const dy = e.touches[1].clientY - e.touches[0].clientY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const mid = {
      x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
      y: (e.touches[0].clientY + e.touches[1].clientY) / 2
    };
    if (lastTouchDist > 0) {
      const zoomFactor = lastTouchDist / dist;
      const [wx, wy] = s2w(mid.x, mid.y);
      cam.scale /= zoomFactor;
      cam.x = wx - (mid.x - W / 2) / cam.scale;
      cam.y = wy - (mid.y - H / 2) / cam.scale;
      scheduleDraw();
    }
    lastTouchDist = dist;
    lastTouchMid = mid;
  }
  e.preventDefault();
}, { passive: false });

canvas.addEventListener("touchend", e => {
  if (!touchMoved && e.changedTouches.length === 1 && root) {
    const t = e.changedTouches[0];
    const hit = hitTest(t.clientX, t.clientY);
    selectNode(hit);
  }
  dragging = false;
  touchMoved = false;
  lastTouchDist = 0;
  lastTouchMid = null;
});

// ── Hit testing ─────────────────────────────────────────────────────
function hitTest(sx, sy) {
  const [wx, wy] = s2w(sx, sy);
  let best = null;
  let bestR = Infinity;
  for (const n of flat) {
    if (n._r * cam.scale < 1.2) continue; // not visible
    const dx = wx - n._x;
    const dy = wy - n._y;
    const d = Math.sqrt(dx * dx + dy * dy);
    // Hit within 15% of node radius, prefer smaller (more specific) nodes
    if (d < n._r * 0.18 && n._r < bestR) {
      bestR = n._r;
      best = n;
    }
  }
  return best;
}

const hoverEl = document.getElementById("hover-info");
const hName = hoverEl.querySelector(".h-name");
const hRank = hoverEl.querySelector(".h-rank");
const hTips = hoverEl.querySelector(".h-tips");

function updateHover(sx, sy) {
  const hit = hitTest(sx, sy);
  if (hit !== hoveredNode) {
    hoveredNode = hit;
    scheduleDraw();
  }
  if (hit && hit._name) {
    hoverEl.classList.add("visible");
    hName.textContent = hit._name;
    hRank.textContent = hit._rank && hit._rank !== "no rank" ? ` \u00b7 ${hit._rank}` : "";
    hTips.textContent = hit._tips > 0 ? ` \u00b7 ${hit._tips} species` : "";
    updateBreadcrumb(hit);
  } else {
    hoverEl.classList.remove("visible");
  }
}

// ── Breadcrumb ──────────────────────────────────────────────────────
const breadcrumbEl = document.getElementById("breadcrumb");

function updateBreadcrumb(node) {
  const path = [];
  let n = node;
  while (n) {
    if (n._name) path.unshift(n);
    n = n._parent;
  }
  breadcrumbEl.innerHTML = path.map(p =>
    `<span data-ott="${p._ottId || ""}">${p._name}</span>`
  ).join(" &rsaquo; ");

  for (const span of breadcrumbEl.querySelectorAll("span")) {
    span.addEventListener("click", () => {
      const ott = span.dataset.ott;
      const target = flat.find(n => String(n._ottId) === ott);
      if (target) flyTo(target);
    });
  }
}

// ── Animation ───────────────────────────────────────────────────────
function flyTo(node, duration) {
  duration = duration || 500;
  const targetScale = Math.min(W, H) / (node._r * 2.8);
  const sx = cam.x, sy = cam.y, ss = cam.scale;
  const tx = node._x, ty = node._y, ts = targetScale;
  const t0 = performance.now();

  function step(now) {
    let t = Math.min(1, (now - t0) / duration);
    t = 1 - Math.pow(1 - t, 3); // ease-out cubic
    cam.x = sx + (tx - sx) * t;
    cam.y = sy + (ty - sy) * t;
    cam.scale = ss * Math.pow(ts / ss, t);
    scheduleDraw();
    if (t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

// ── Info panel ──────────────────────────────────────────────────────
const infoCache = {};
const ozCache = {};
const IUCN_LABELS = {
  LC: "Least Concern", NT: "Near Threatened", VU: "Vulnerable",
  EN: "Endangered", CR: "Critically Endangered", EW: "Extinct in Wild",
  EX: "Extinct", DD: "Data Deficient"
};

async function fetchTaxonInfo(ottId) {
  if (infoCache[ottId]) return infoCache[ottId];
  const r = await fetch(`${API}/taxonomy/taxon_info`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ ott_id: ottId, include_lineage: false })
  });
  const d = await r.json();
  infoCache[ottId] = d;
  return d;
}

async function fetchOneZoom(ottId) {
  if (ozCache[ottId]) return ozCache[ottId];
  try {
    const r = await fetch(`https://www.onezoom.org/API/otts2identifiers?key=0&otts=${ottId}`);
    const d = await r.json();
    const row = d && d[0] ? d[0] : {};
    ozCache[ottId] = row;
    return row;
  } catch { ozCache[ottId] = {}; return {}; }
}

function buildLinks(ottId, name, taxSources, oz) {
  const links = [];
  if (oz && oz.wikidata) {
    links.push({ label: "Wikidata", url: `https://www.wikidata.org/wiki/${oz.wikidata}`, cat: "reference" });
  }
  links.push({ label: "Wikipedia", url: `https://en.wikipedia.org/wiki/${encodeURIComponent(name)}`, cat: "reference" });
  if (oz && oz.eol) {
    links.push({ label: "Encyclopedia of Life", url: `https://eol.org/pages/${oz.eol}`, cat: "reference" });
  }
  if (oz && oz.iucn) {
    links.push({ label: "IUCN Red List", url: `https://www.iucnredlist.org/species/${oz.iucn}`, cat: "conservation" });
  }
  links.push({ label: "OneZoom", url: `https://www.onezoom.org/life/@=${ottId}`, cat: "tree" });
  links.push({ label: "Open Tree of Life", url: `https://tree.opentreeoflife.org/taxonomy/browse?id=${ottId}`, cat: "tree" });
  for (const src of (taxSources || [])) {
    const [prefix, id] = src.split(":");
    switch (prefix) {
      case "ncbi":
        links.push({ label: "NCBI Taxonomy", url: `https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=${id}`, cat: "database" });
        break;
      case "gbif":
        links.push({ label: "GBIF", url: `https://www.gbif.org/species/${id}`, cat: "database" });
        break;
      case "worms":
        links.push({ label: "WoRMS", url: `https://www.marinespecies.org/aphia.php?p=taxdetails&id=${id}`, cat: "database" });
        break;
      case "irmng":
        links.push({ label: "IRMNG", url: `https://www.irmng.org/aphia.php?p=taxdetails&id=${id}`, cat: "database" });
        break;
    }
  }
  return links;
}

function renderInfoPanel(inner, ottId, name, rank, data, oz) {
  const links = buildLinks(ottId, data.name || name, data.tax_sources, oz);
  const synonyms = (data.synonyms || []).filter(s => s !== name);
  const flags = (data.flags || []).filter(f => f);
  const iucnCode = oz && oz.iucn ? (oz.iucn_code || null) : null;

  let html = `<span class="info-close">&times;</span>`;
  html += `<h2>${data.unique_name || data.name || name}`;
  if (iucnCode && IUCN_LABELS[iucnCode]) {
    html += ` <span class="iucn-badge iucn-${iucnCode}" title="${IUCN_LABELS[iucnCode]}">${iucnCode}</span>`;
  }
  html += `</h2>`;
  html += (data.rank && data.rank !== "no rank")
    ? `<div class="info-rank">${data.rank} · ott${ottId}</div>`
    : `<div class="info-rank">ott${ottId}</div>`;

  if (data.num_tips) {
    html += `<div class="info-rank">${data.num_tips.toLocaleString()} descendant species</div>`;
  }

  const cats = [
    { key: "reference", label: "Reference" },
    { key: "conservation", label: "Conservation" },
    { key: "tree", label: "Tree Browsers" },
    { key: "database", label: "Databases" }
  ];
  for (const cat of cats) {
    const catLinks = links.filter(l => l.cat === cat.key);
    if (catLinks.length === 0) continue;
    html += `<div class="info-section"><div class="info-label">${cat.label}</div>`;
    for (const lnk of catLinks) {
      html += `<a href="${lnk.url}" target="_blank" rel="noopener">${lnk.label}</a>`;
    }
    html += `</div>`;
  }

  if (synonyms.length > 0) {
    html += `<div class="info-section"><div class="info-label">Synonyms</div>`;
    html += `<div class="info-synonyms">${synonyms.map(s => `<span>${s}</span>`).join(", ")}</div></div>`;
  }
  if (flags.length > 0) {
    html += `<div class="info-section"><div class="info-flags">${flags.join(", ")}</div></div>`;
  }
  inner.innerHTML = html;
  inner.querySelector(".info-close").onclick = () => {
    document.getElementById("info-panel").classList.remove("open");
    selectedNode = null;
    scheduleDraw();
  };
}

function selectNode(node) {
  const panel = document.getElementById("info-panel");
  const inner = document.getElementById("info-inner");

  if (!node || !node._name || !node._ottId) {
    // Clicked empty space — deselect
    selectedNode = null;
    panel.classList.remove("open");
    scheduleDraw();
    return;
  }

  selectedNode = node;
  scheduleDraw();

  panel.classList.add("open");
  inner.innerHTML = `<span class="info-close">&times;</span><h2>${node._name}</h2>` +
    (node._rank && node._rank !== "no rank" ? `<div class="info-rank">${node._rank}</div>` : "") +
    `<div class="info-loading">fetching…</div>`;
  inner.querySelector(".info-close").onclick = () => {
    panel.classList.remove("open");
    selectedNode = null;
    scheduleDraw();
  };

  const pOtl = fetchTaxonInfo(node._ottId);
  const pOz = fetchOneZoom(node._ottId);

  pOtl.then(data => {
    renderInfoPanel(inner, node._ottId, node._name, node._rank, data, {});
    pOz.then(oz => renderInfoPanel(inner, node._ottId, node._name, node._rank, data, oz));
  }).catch(() => {
    const loading = inner.querySelector(".info-loading");
    if (loading) loading.textContent = "couldn't load info";
  });
}

// ── Init ────────────────────────────────────────────────────────────
(async () => {
  const status = document.getElementById("status");
  resize();

  try {
    status.textContent = "fetching primates\u2026";
    const tree = await fetchTree(OTT_ROOT);
    status.textContent = "laying out\u2026";
    root = tree;

    layoutTree(root, 0, 0, 1, 0, Math.PI * 2, 0, null);

    // Initial camera: fit root
    cam.scale = Math.min(W, H) * 0.38;

    status.textContent = `${flat.length} nodes \u00b7 scroll to zoom \u00b7 drag to pan \u00b7 click node for info \u00b7 double-click to focus`;
    scheduleDraw();
  } catch (e) {
    status.textContent = `error: ${e.message}`;
  }
})();
</script>
</body>
</html>
