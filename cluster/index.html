<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>cluster â€” mino.mobi</title>
<style>
:root {
  --bg: #faf9f6;
  --text: #1a1a1a;
  --muted: #777;
  --rule: #ccc;
  --link: #8b0000;
  --mono: 'SF Mono', 'Cascadia Code', 'Fira Code', Menlo, monospace;
  --serif: 'Iowan Old Style', 'Palatino Linotype', Palatino, Georgia, serif;
}
@media (prefers-color-scheme: dark) {
  :root {
    --bg: #0f0f0f;
    --text: #d4d4d4;
    --muted: #777;
    --rule: #333;
    --link: #c45;
  }
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: var(--serif);
  line-height: 1.7;
  padding: 4rem 2rem;
  max-width: 720px;
  margin: 0 auto;
}

h1 {
  font-family: var(--mono);
  font-size: 0.85rem;
  font-weight: 400;
  letter-spacing: 0.15em;
  text-transform: lowercase;
  color: var(--muted);
  margin-bottom: 0.5rem;
}

h1 a { color: var(--muted); text-decoration: none; }
h1 a:hover { color: var(--text); }

.subtitle {
  font-size: 1.15rem;
  color: var(--text);
  margin-bottom: 1rem;
}

.desc {
  font-size: 0.95rem;
  color: var(--muted);
  margin-bottom: 2.5rem;
}

.handle-form {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 2rem;
}

.handle-form input {
  flex: 1;
  font-family: var(--mono);
  font-size: 0.85rem;
  padding: 0.5rem 0.75rem;
  border: 1px solid var(--rule);
  background: var(--bg);
  color: var(--text);
  min-width: 0;
}

.handle-form input:focus {
  outline: none;
  border-color: var(--link);
}

.handle-form button,
.auth-form button,
.rescan-btn {
  font-family: var(--mono);
  font-size: 0.75rem;
  letter-spacing: 0.05em;
  padding: 0.5rem 1.25rem;
  border: 1px solid var(--rule);
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  white-space: nowrap;
}

.handle-form button:hover,
.auth-form button:hover,
.rescan-btn:hover {
  border-color: var(--link);
  color: var(--link);
}

.handle-form button:disabled,
.auth-form button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.progress-track {
  width: 100%;
  height: 1px;
  background: var(--rule);
  margin-bottom: 1.5rem;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: var(--link);
  width: 0%;
  transition: width 0.3s ease;
}

.status-line {
  font-family: var(--mono);
  font-size: 0.75rem;
  color: var(--muted);
  margin-bottom: 1.5rem;
}

.status-line.error {
  color: var(--link);
}

.graph-stats {
  font-family: var(--mono);
  font-size: 0.75rem;
  color: var(--muted);
  margin-bottom: 2rem;
  line-height: 1.9;
}

.section-header {
  font-family: var(--mono);
  font-size: 0.7rem;
  color: var(--muted);
  letter-spacing: 0.05em;
  margin-bottom: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--rule);
}

.shell-section {
  margin-top: 2.5rem;
}

.result-row {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.6rem 0;
  border-bottom: 1px solid var(--rule);
}

.result-row:last-child {
  border-bottom: none;
}

.pfp {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  object-fit: cover;
  background: var(--rule);
  flex-shrink: 0;
}

.result-info {
  flex: 1;
  min-width: 0;
}

.result-handle {
  font-family: var(--mono);
  font-size: 0.8rem;
  color: var(--link);
  text-decoration: none;
  display: block;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.result-handle:hover {
  text-decoration: underline;
}

.result-name {
  font-size: 0.85rem;
  color: var(--text);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.result-meta {
  font-family: var(--mono);
  font-size: 0.7rem;
  color: var(--muted);
  flex-shrink: 0;
  text-align: right;
}

.empty-state {
  font-size: 0.95rem;
  color: var(--muted);
  text-align: center;
  padding: 3rem 0;
  font-style: italic;
}

.publish-section {
  margin-top: 3rem;
  padding-top: 2rem;
  border-top: 1px solid var(--rule);
}

.publish-section .section-header {
  border-bottom: none;
  padding-bottom: 0;
  margin-bottom: 0.5rem;
}

.publish-desc {
  font-size: 0.85rem;
  color: var(--muted);
  margin-bottom: 1.5rem;
}

.publish-desc a {
  color: var(--link);
  text-decoration: none;
}

.publish-desc a:hover {
  text-decoration: underline;
}

.auth-form {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.auth-form input {
  font-family: var(--mono);
  font-size: 0.85rem;
  padding: 0.5rem 0.75rem;
  border: 1px solid var(--rule);
  background: var(--bg);
  color: var(--text);
  min-width: 0;
}

.auth-form input:focus {
  outline: none;
  border-color: var(--link);
}

.auth-form input[type="text"] { flex: 1; min-width: 140px; }
.auth-form input[type="password"] { flex: 1; min-width: 140px; }

.publish-status {
  font-family: var(--mono);
  font-size: 0.75rem;
  color: var(--muted);
  margin-top: 0.75rem;
}

.publish-status.error {
  color: var(--link);
}

.rescan-offer {
  margin-top: 2rem;
  font-family: var(--mono);
  font-size: 0.75rem;
  color: var(--muted);
}

hr {
  border: none;
  border-top: 1px solid var(--rule);
  margin: 3rem 0;
}

footer {
  margin-top: 4rem;
  font-family: var(--mono);
  font-size: 0.7rem;
  color: var(--muted);
  letter-spacing: 0.05em;
}

footer a {
  color: var(--muted);
  text-decoration: none;
}

footer a:hover {
  color: var(--text);
}

.hidden { display: none !important; }
</style>
</head>
<body>

<h1><a href="/">mino.mobi</a> / cluster</h1>

<p class="subtitle">Find your tightest circle.</p>

<p class="desc">
  Enter your Bluesky handle to find the largest group of your follows
  who all mutually follow each other&mdash;every node connected to every
  other node. If you&rsquo;ve published a cluster list before, the shells
  expand from it cheaply.
</p>

<form class="handle-form" id="handleForm">
  <input type="text" id="handleInput" placeholder="handle.bsky.social" autocomplete="off" spellcheck="false">
  <button type="submit" id="loadBtn">cluster</button>
</form>

<div class="progress-track hidden" id="progressBar">
  <div class="progress-fill" id="progressFill"></div>
</div>

<div class="status-line hidden" id="status"></div>
<div class="graph-stats hidden" id="graphStats"></div>
<div id="results"></div>

<div id="rescanOffer" class="rescan-offer hidden">
  <button class="rescan-btn" id="rescanBtn">full rescan</button>
  &mdash; recompute the clique from scratch (slower)
</div>

<div id="publishSection" class="publish-section hidden">
  <div class="section-header">publish as list</div>
  <p class="publish-desc">
    Save this cluster to your Bluesky account as a curated list.
    Requires an <a href="https://bsky.app/settings/app-passwords" target="_blank" rel="noopener">app password</a>.
  </p>
  <form class="auth-form" id="publishForm">
    <input type="text" id="authHandle" placeholder="your-handle.bsky.social" autocomplete="username">
    <input type="password" id="authPassword" placeholder="app password" autocomplete="current-password">
    <button type="submit" id="publishBtn">publish</button>
  </form>
  <div class="publish-status hidden" id="publishStatus"></div>
</div>

<footer>
  <a href="/">mino.mobi</a> &middot;
  <a href="https://bsky.app/profile/mino.mobi">@mino.mobi</a>
</footer>

<script>
(function () {
  const PUBLIC_API = 'https://public.api.bsky.app';

  // --- Module state ---
  let publishMembers = [];
  let currentProfileMap = new Map();

  // --- Identity resolution ---

  async function resolveHandle(handle) {
    const res = await fetch(
      `${PUBLIC_API}/xrpc/com.atproto.identity.resolveHandle?handle=${encodeURIComponent(handle)}`
    );
    if (!res.ok) throw new Error(`Could not resolve handle: ${handle}`);
    return (await res.json()).did;
  }

  async function resolvePDS(did) {
    let doc;
    if (did.startsWith('did:plc:')) {
      const res = await fetch(`https://plc.directory/${did}`);
      if (!res.ok) throw new Error(`Could not resolve DID: ${did}`);
      doc = await res.json();
    } else if (did.startsWith('did:web:')) {
      const host = did.slice('did:web:'.length).replaceAll(':', '/');
      const res = await fetch(`https://${host}/.well-known/did.json`);
      if (!res.ok) throw new Error(`Could not resolve DID: ${did}`);
      doc = await res.json();
    } else {
      throw new Error(`Unsupported DID method: ${did}`);
    }
    const svc = doc.service?.find(s => s.type === 'AtprotoPersonalDataServer');
    if (!svc) throw new Error('No PDS endpoint found');
    return svc.serviceEndpoint;
  }

  // --- API helpers ---

  async function fetchJSON(url, retries = 3) {
    for (let i = 0; i <= retries; i++) {
      const res = await fetch(url);
      if (res.status === 429) {
        await new Promise(r => setTimeout(r, Math.pow(2, i) * 1000));
        continue;
      }
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }
    throw new Error('Rate limited');
  }

  async function getAllFollows(actor, onProgress) {
    const follows = [];
    let cursor;
    do {
      const params = new URLSearchParams({ actor, limit: '100' });
      if (cursor) params.set('cursor', cursor);
      const data = await fetchJSON(
        `${PUBLIC_API}/xrpc/app.bsky.graph.getFollows?${params}`
      );
      follows.push(...(data.follows || []));
      cursor = data.cursor;
      if (onProgress) onProgress(follows.length);
    } while (cursor);
    return follows;
  }

  async function mapConcurrent(items, concurrency, fn) {
    let index = 0;
    async function worker() {
      while (index < items.length) {
        const i = index++;
        await fn(items[i], i);
      }
    }
    await Promise.all(Array.from({ length: concurrency }, () => worker()));
  }

  // --- List detection ---

  async function findClusterList(did) {
    try {
      const params = new URLSearchParams({
        repo: did, collection: 'app.bsky.graph.list', limit: '100'
      });
      const data = await fetchJSON(
        `${PUBLIC_API}/xrpc/com.atproto.repo.listRecords?${params}`
      );
      let best = null;
      for (const r of (data.records || [])) {
        if (r.value?.description?.includes('mino.mobi/cluster')) best = r.uri;
      }
      return best;
    } catch { return null; }
  }

  async function getListMembers(listUri) {
    const members = [];
    let cursor;
    do {
      const params = new URLSearchParams({ list: listUri, limit: '100' });
      if (cursor) params.set('cursor', cursor);
      const data = await fetchJSON(
        `${PUBLIC_API}/xrpc/app.bsky.graph.getList?${params}`
      );
      for (const item of (data.items || [])) members.push(item.subject);
      cursor = data.cursor;
    } while (cursor);
    return members;
  }

  // --- Bron-Kerbosch with pivot and pruning ---

  function findMaxClique(adj, nodeList) {
    let best = [];
    let ops = 0;
    const LIMIT = 5_000_000;

    function neighborsInSet(v, s) {
      let c = 0;
      const n = adj.get(v);
      if (!n) return 0;
      for (const u of n) if (s.has(u)) c++;
      return c;
    }

    function bk(clique, P, X) {
      if (ops++ > LIMIT) return;
      if (P.size === 0 && X.size === 0) {
        if (clique.length > best.length) best = [...clique];
        return;
      }
      if (clique.length + P.size <= best.length) return;

      let pivot = null, maxN = -1;
      for (const v of P) {
        const n = neighborsInSet(v, P);
        if (n > maxN) { pivot = v; maxN = n; }
      }
      for (const v of X) {
        const n = neighborsInSet(v, P);
        if (n > maxN) { pivot = v; maxN = n; }
      }

      const pivotN = adj.get(pivot) || new Set();
      const candidates = [];
      for (const v of P) if (!pivotN.has(v)) candidates.push(v);

      for (const v of candidates) {
        if (ops > LIMIT) return;
        const vN = adj.get(v) || new Set();
        const newP = new Set();
        const newX = new Set();
        for (const u of P) if (vN.has(u)) newP.add(u);
        for (const u of X) if (vN.has(u)) newX.add(u);

        clique.push(v);
        bk(clique, newP, newX);
        clique.pop();

        P.delete(v);
        X.add(v);
      }
    }

    bk([], new Set(nodeList), new Set());
    return { clique: best, exhaustive: ops <= LIMIT };
  }

  // --- Rendering ---

  function escapeHtml(str) {
    const el = document.createElement('span');
    el.textContent = str || '';
    return el.innerHTML;
  }

  function renderPersonRow(did, profileMap, meta) {
    const p = profileMap.get(did) || {};
    const handle = escapeHtml(p.handle || did);
    const name = escapeHtml(p.displayName || p.handle || did);
    const url = p.handle
      ? `https://bsky.app/profile/${encodeURIComponent(p.handle)}`
      : '#';
    const avatar = p.avatar || '';

    return `<div class="result-row">
      ${avatar
        ? `<img class="pfp" src="${escapeHtml(avatar)}" alt="" loading="lazy">`
        : `<div class="pfp"></div>`}
      <div class="result-info">
        <a class="result-handle" href="${url}" target="_blank" rel="noopener">@${handle}</a>
        <div class="result-name">${name}</div>
      </div>
      ${meta ? `<div class="result-meta">${meta}</div>` : ''}
    </div>`;
  }

  function renderShells(coreDids, coreSize, shells, profileMap) {
    const results = document.getElementById('results');
    let html = '';

    // Core
    html += `<div class="section-header">core \u00b7 ${coreDids.length} people</div>`;
    html += coreDids.map(did => renderPersonRow(did, profileMap)).join('');

    // Shells
    for (let i = 0; i < shells.length; i++) {
      const sh = shells[i];
      html += `<div class="shell-section">`;
      html += `<div class="section-header">shell ${i + 1} \u00b7 ${sh.members.length} people \u00b7 ${sh.threshold}/${coreSize} mutual</div>`;
      html += sh.members.map(m =>
        renderPersonRow(m.did, profileMap, `${m.count}/${coreSize}`)
      ).join('');
      html += `</div>`;
    }

    if (coreDids.length === 0) {
      html = '<div class="empty-state">No mutual clique found among your follows.</div>';
    }

    results.innerHTML = html;
  }

  // --- Fast path: shell peel from existing cluster list ---

  async function fastPath(did, status, progressFill, graphStats) {
    status.textContent = 'checking for cluster list\u2026';
    const listUri = await findClusterList(did);
    if (!listUri) return false;

    status.textContent = 'loading cluster list\u2026';
    const members = await getListMembers(listUri);
    if (members.length === 0) return false;

    const coreDids = members.map(m => m.did);
    const coreSet = new Set(coreDids);
    const coreSize = members.length;
    currentProfileMap = new Map();
    for (const m of members) currentProfileMap.set(m.did, m);

    // Phase 1: fetch follows for each core member
    const memberFollows = new Map();
    let scanned = 0;
    await mapConcurrent(members, 5, async (member) => {
      try {
        const follows = await getAllFollows(member.did);
        memberFollows.set(member.did, new Set(follows.map(f => f.did)));
        for (const f of follows) {
          if (!currentProfileMap.has(f.did)) currentProfileMap.set(f.did, f);
        }
      } catch {
        memberFollows.set(member.did, new Set());
      }
      scanned++;
      status.textContent = `scanning core follows\u2026 ${scanned}/${coreSize}`;
      progressFill.style.width = (scanned / coreSize * 50) + '%';
    });

    // Count: for each non-member, how many core members follow them
    const followedBy = new Map();
    for (const [, follows] of memberFollows) {
      for (const d of follows) {
        if (coreSet.has(d)) continue;
        followedBy.set(d, (followedBy.get(d) || 0) + 1);
      }
    }

    // Filter candidates worth verifying
    const minThreshold = Math.max(5, Math.ceil(coreSize / 2));
    const candidateDids = [...followedBy.entries()]
      .filter(([, count]) => count >= minThreshold)
      .sort((a, b) => b[1] - a[1])
      .map(([d]) => d);

    // Phase 2: fetch candidates' follows for reciprocity check
    const candidateFollows = new Map();
    let verified = 0;
    if (candidateDids.length > 0) {
      await mapConcurrent(candidateDids, 5, async (d) => {
        try {
          const follows = await getAllFollows(d);
          candidateFollows.set(d, new Set(follows.map(f => f.did)));
        } catch {
          candidateFollows.set(d, new Set());
        }
        verified++;
        status.textContent = `verifying candidates\u2026 ${verified}/${candidateDids.length}`;
        progressFill.style.width = (50 + verified / candidateDids.length * 50) + '%';
      });
    }

    // Compute mutual counts
    const mutualCounts = new Map();
    for (const candidateDid of candidateDids) {
      const theirFollows = candidateFollows.get(candidateDid) || new Set();
      let count = 0;
      for (const [memberDid, memberFollowSet] of memberFollows) {
        if (memberFollowSet.has(candidateDid) && theirFollows.has(memberDid)) count++;
      }
      if (count >= minThreshold) mutualCounts.set(candidateDid, count);
    }

    // Shell peel
    const shells = [];
    const assigned = new Set(coreSet);
    for (let t = coreSize - 1; t >= minThreshold; t--) {
      const layer = [];
      for (const [d, count] of mutualCounts) {
        if (assigned.has(d)) continue;
        if (count >= t) layer.push({ did: d, count });
      }
      if (layer.length === 0) continue;
      layer.sort((a, b) => b.count - a.count);
      for (const m of layer) assigned.add(m.did);
      shells.push({ threshold: t, members: layer });
    }

    // Stats
    const totalShell = shells.reduce((s, sh) => s + sh.members.length, 0);
    graphStats.innerHTML =
      `cluster list \u00b7 ${coreSize} core \u2192 ${candidateDids.length} candidates \u2192 ${shells.length} shells (${totalShell} people)`;
    graphStats.classList.remove('hidden');
    status.textContent = `done \u00b7 ${coreSize} core + ${totalShell} in ${shells.length} shells`;
    progressFill.style.width = '100%';

    renderShells(coreDids, coreSize, shells, currentProfileMap);

    publishMembers = [...coreDids];
    for (const sh of shells) for (const m of sh.members) publishMembers.push(m.did);

    document.getElementById('rescanOffer').classList.remove('hidden');
    return true;
  }

  // --- Full path: scan all follows, find clique, shell peel ---

  async function fullPath(did, status, progressFill, graphStats) {
    status.textContent = 'fetching your follows\u2026';
    const myFollows = await getAllFollows(did, (n) => {
      status.textContent = `fetching your follows\u2026 ${n}`;
    });

    const myFollowDids = new Set(myFollows.map(f => f.did));
    currentProfileMap = new Map();
    for (const f of myFollows) currentProfileMap.set(f.did, f);

    // Build directed adjacency
    const directed = new Map();
    let scanned = 0;
    await mapConcurrent(myFollows, 5, async (follow) => {
      try {
        const theirFollows = await getAllFollows(follow.did);
        const overlap = new Set();
        for (const f of theirFollows) {
          if (myFollowDids.has(f.did) && f.did !== follow.did) overlap.add(f.did);
        }
        directed.set(follow.did, overlap);
      } catch {
        directed.set(follow.did, new Set());
      }
      scanned++;
      status.textContent = `scanning follows\u2026 ${scanned}/${myFollows.length}`;
      progressFill.style.width = (scanned / myFollows.length * 100) + '%';
    });

    // Build mutual adjacency
    status.textContent = 'building mutual graph\u2026';
    const mutual = new Map();
    let mutualEdges = 0;
    for (const [a, aFollows] of directed) {
      const m = new Set();
      for (const b of aFollows) {
        if (directed.get(b)?.has(a)) m.add(b);
      }
      if (m.size > 0) mutual.set(a, m);
      mutualEdges += m.size;
    }
    mutualEdges /= 2;

    const mutualNodes = [...mutual.keys()];
    graphStats.innerHTML =
      `${myFollows.length} follows \u2192 ${mutualNodes.length} with mutual connections \u2192 ${Math.round(mutualEdges)} mutual edges`;
    graphStats.classList.remove('hidden');

    // Find maximum clique
    status.textContent = 'computing largest clique\u2026';
    progressFill.style.width = '100%';
    await new Promise(r => setTimeout(r, 50));

    const { clique, exhaustive } = findMaxClique(mutual, mutualNodes);
    const cliqueSet = new Set(clique);
    const coreSize = clique.length;

    // Shell peel from clique
    const shells = [];
    if (coreSize > 0) {
      const assigned = new Set(clique);
      const minThreshold = Math.max(5, Math.ceil(coreSize / 2));
      for (let t = coreSize - 1; t >= minThreshold; t--) {
        const layer = [];
        for (const [node, neighbors] of mutual) {
          if (assigned.has(node)) continue;
          const count = [...cliqueSet].filter(c => neighbors.has(c)).length;
          if (count >= t) layer.push({ did: node, count });
        }
        if (layer.length === 0) continue;
        layer.sort((a, b) => b.count - a.count);
        for (const m of layer) assigned.add(m.did);
        shells.push({ threshold: t, members: layer });
      }
    }

    const totalShell = shells.reduce((s, sh) => s + sh.members.length, 0);
    status.textContent = exhaustive
      ? `done \u00b7 clique of ${coreSize}${totalShell > 0 ? ` + ${totalShell} in ${shells.length} shells` : ''}`
      : `done \u00b7 best clique: ${coreSize} (search limit reached)`;

    renderShells(clique, coreSize, shells, currentProfileMap);

    publishMembers = [...clique];
    for (const sh of shells) for (const m of sh.members) publishMembers.push(m.did);
  }

  // --- Publish as list ---

  document.getElementById('publishForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const authHandle = document.getElementById('authHandle').value.trim().replace(/^@/, '');
    const authPassword = document.getElementById('authPassword').value;
    const publishBtn = document.getElementById('publishBtn');
    const publishStatus = document.getElementById('publishStatus');

    if (!authHandle || !authPassword) return;

    publishBtn.disabled = true;
    publishBtn.textContent = 'publishing\u2026';
    publishStatus.classList.remove('hidden', 'error');
    publishStatus.textContent = 'authenticating\u2026';

    try {
      const did = await resolveHandle(authHandle);
      const pds = await resolvePDS(did);

      const sessionRes = await fetch(`${pds}/xrpc/com.atproto.server.createSession`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ identifier: authHandle, password: authPassword })
      });
      if (!sessionRes.ok) {
        const err = await sessionRes.json().catch(() => ({}));
        throw new Error(err.message || `Auth failed (${sessionRes.status})`);
      }
      const session = await sessionRes.json();
      const token = session.accessJwt;
      const repoDid = session.did;

      document.getElementById('authPassword').value = '';

      publishStatus.textContent = 'creating list\u2026';
      const listRes = await fetch(`${pds}/xrpc/com.atproto.repo.createRecord`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          repo: repoDid,
          collection: 'app.bsky.graph.list',
          record: {
            $type: 'app.bsky.graph.list',
            purpose: 'app.bsky.graph.defs#curatelist',
            name: `Cluster (${publishMembers.length})`,
            description: `Mutual-follow cluster with shells, found by mino.mobi/cluster`,
            createdAt: new Date().toISOString()
          }
        })
      });
      if (!listRes.ok) throw new Error(`Failed to create list (${listRes.status})`);
      const { uri: listUri } = await listRes.json();

      for (let i = 0; i < publishMembers.length; i++) {
        publishStatus.textContent = `adding members\u2026 ${i + 1}/${publishMembers.length}`;
        await fetch(`${pds}/xrpc/com.atproto.repo.createRecord`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            repo: repoDid,
            collection: 'app.bsky.graph.listitem',
            record: {
              $type: 'app.bsky.graph.listitem',
              subject: publishMembers[i],
              list: listUri,
              createdAt: new Date().toISOString()
            }
          })
        });
      }

      const rkey = listUri.split('/').pop();
      const listUrl = `https://bsky.app/profile/${encodeURIComponent(authHandle)}/lists/${rkey}`;
      publishStatus.innerHTML = `done \u00b7 ${publishMembers.length} members \u00b7 <a href="${listUrl}" target="_blank" rel="noopener" style="color:var(--link)">view list</a>`;

    } catch (err) {
      publishStatus.textContent = `error: ${err.message}`;
      publishStatus.classList.add('error');
    } finally {
      publishBtn.disabled = false;
      publishBtn.textContent = 'publish';
    }
  });

  // --- Main ---

  let forceFullScan = false;

  document.getElementById('handleForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const raw = document.getElementById('handleInput').value.trim().replace(/^@/, '');
    if (!raw) return;

    const loadBtn = document.getElementById('loadBtn');
    const progressBar = document.getElementById('progressBar');
    const progressFill = document.getElementById('progressFill');
    const status = document.getElementById('status');
    const graphStats = document.getElementById('graphStats');

    loadBtn.disabled = true;
    loadBtn.textContent = 'scanning\u2026';
    progressBar.classList.remove('hidden');
    progressFill.style.width = '0%';
    status.classList.remove('hidden', 'error');
    status.textContent = 'resolving handle\u2026';
    graphStats.classList.add('hidden');
    document.getElementById('results').innerHTML = '';
    document.getElementById('publishSection').classList.add('hidden');
    document.getElementById('rescanOffer').classList.add('hidden');

    const pageUrl = new URL(window.location);
    pageUrl.searchParams.set('handle', raw);
    window.history.replaceState({}, '', pageUrl);

    try {
      const did = await resolveHandle(raw);

      let usedFast = false;
      if (!forceFullScan) {
        usedFast = await fastPath(did, status, progressFill, graphStats);
      }
      forceFullScan = false;

      if (!usedFast) {
        await fullPath(did, status, progressFill, graphStats);
      }

      if (publishMembers.length > 0) {
        document.getElementById('authHandle').value = raw;
        document.getElementById('publishSection').classList.remove('hidden');
        document.getElementById('publishStatus').classList.add('hidden');
      }

    } catch (err) {
      status.textContent = `error: ${err.message}`;
      status.classList.add('error');
      progressFill.style.width = '0%';
    } finally {
      loadBtn.disabled = false;
      loadBtn.textContent = 'cluster';
    }
  });

  // Rescan button
  document.getElementById('rescanBtn').addEventListener('click', () => {
    forceFullScan = true;
    document.getElementById('handleForm').dispatchEvent(new Event('submit'));
  });

  // Auto-load from URL
  const h = new URLSearchParams(location.search).get('handle');
  if (h) {
    document.getElementById('handleInput').value = h;
    document.getElementById('handleForm').dispatchEvent(new Event('submit'));
  }
})();
</script>

</body>
</html>
