<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>cluster — mino.mobi</title>
<style>
:root {
  --bg: #faf9f6;
  --text: #1a1a1a;
  --muted: #777;
  --rule: #ccc;
  --link: #8b0000;
  --mono: 'SF Mono', 'Cascadia Code', 'Fira Code', Menlo, monospace;
  --serif: 'Iowan Old Style', 'Palatino Linotype', Palatino, Georgia, serif;
}
@media (prefers-color-scheme: dark) {
  :root {
    --bg: #0f0f0f;
    --text: #d4d4d4;
    --muted: #777;
    --rule: #333;
    --link: #c45;
  }
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: var(--serif);
  line-height: 1.7;
  padding: 4rem 2rem;
  max-width: 720px;
  margin: 0 auto;
}

h1 {
  font-family: var(--mono);
  font-size: 0.85rem;
  font-weight: 400;
  letter-spacing: 0.15em;
  text-transform: lowercase;
  color: var(--muted);
  margin-bottom: 0.5rem;
}

h1 a { color: var(--muted); text-decoration: none; }
h1 a:hover { color: var(--text); }

.subtitle {
  font-size: 1.15rem;
  color: var(--text);
  margin-bottom: 1rem;
}

.desc {
  font-size: 0.95rem;
  color: var(--muted);
  margin-bottom: 2.5rem;
}

.handle-form {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 2rem;
}

.handle-form input {
  flex: 1;
  font-family: var(--mono);
  font-size: 0.85rem;
  padding: 0.5rem 0.75rem;
  border: 1px solid var(--rule);
  background: var(--bg);
  color: var(--text);
  min-width: 0;
}

.handle-form input:focus {
  outline: none;
  border-color: var(--link);
}

.handle-form button,
.auth-form button,
.rescan-btn {
  font-family: var(--mono);
  font-size: 0.75rem;
  letter-spacing: 0.05em;
  padding: 0.5rem 1.25rem;
  border: 1px solid var(--rule);
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  white-space: nowrap;
}

.handle-form button:hover,
.auth-form button:hover,
.rescan-btn:hover {
  border-color: var(--link);
  color: var(--link);
}

.handle-form button:disabled,
.auth-form button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.progress-track {
  width: 100%;
  height: 1px;
  background: var(--rule);
  margin-bottom: 1.5rem;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: var(--link);
  width: 0%;
  transition: width 0.3s ease;
}

.status-line {
  font-family: var(--mono);
  font-size: 0.75rem;
  color: var(--muted);
  margin-bottom: 1.5rem;
}

.status-line.error {
  color: var(--link);
}

.graph-stats {
  font-family: var(--mono);
  font-size: 0.75rem;
  color: var(--muted);
  margin-bottom: 2rem;
  line-height: 1.9;
}

.section-header {
  font-family: var(--mono);
  font-size: 0.7rem;
  color: var(--muted);
  letter-spacing: 0.05em;
  margin-bottom: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--rule);
}

.shell-section {
  margin-top: 2.5rem;
}

.result-row {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.6rem 0;
  border-bottom: 1px solid var(--rule);
}

.result-row:last-child {
  border-bottom: none;
}

.pfp {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  object-fit: cover;
  background: var(--rule);
  flex-shrink: 0;
}

.result-info {
  flex: 1;
  min-width: 0;
}

.result-handle {
  font-family: var(--mono);
  font-size: 0.8rem;
  color: var(--link);
  text-decoration: none;
  display: block;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.result-handle:hover {
  text-decoration: underline;
}

.result-name {
  font-size: 0.85rem;
  color: var(--text);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.result-meta {
  font-family: var(--mono);
  font-size: 0.7rem;
  color: var(--muted);
  flex-shrink: 0;
  text-align: right;
}

.empty-state {
  font-size: 0.95rem;
  color: var(--muted);
  text-align: center;
  padding: 3rem 0;
  font-style: italic;
}

#graphContainer {
  margin-top: 2.5rem;
  margin-bottom: 0.5rem;
}

#graphContainer canvas {
  width: 100%;
  display: block;
  border: 1px solid var(--rule);
}

.publish-section {
  margin-top: 3rem;
  padding-top: 2rem;
  border-top: 1px solid var(--rule);
}

.publish-section .section-header {
  border-bottom: none;
  padding-bottom: 0;
  margin-bottom: 0.5rem;
}

.publish-desc {
  font-size: 0.85rem;
  color: var(--muted);
  margin-bottom: 1.5rem;
}

.publish-desc a {
  color: var(--link);
  text-decoration: none;
}

.publish-desc a:hover {
  text-decoration: underline;
}

.auth-form {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-bottom: 1.5rem;
}

.auth-form input {
  font-family: var(--mono);
  font-size: 0.85rem;
  padding: 0.5rem 0.75rem;
  border: 1px solid var(--rule);
  background: var(--bg);
  color: var(--text);
  min-width: 0;
}

.auth-form input:focus {
  outline: none;
  border-color: var(--link);
}

.auth-form input[type="text"] { flex: 1; min-width: 140px; }
.auth-form input[type="password"] { flex: 1; min-width: 140px; }

.publish-card {
  padding: 0.75rem 0;
  border-bottom: 1px solid var(--rule);
}

.publish-card:last-child { border-bottom: none; }

.publish-card-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.publish-card-label {
  font-family: var(--mono);
  font-size: 0.75rem;
  letter-spacing: 0.05em;
  color: var(--text);
  min-width: 5rem;
}

.publish-select {
  font-family: var(--mono);
  font-size: 0.75rem;
  padding: 0.35rem 0.5rem;
  border: 1px solid var(--rule);
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  flex: 1;
  min-width: 120px;
}

.publish-select:focus {
  outline: none;
  border-color: var(--link);
}

.publish-card-btn {
  font-family: var(--mono);
  font-size: 0.7rem;
  letter-spacing: 0.05em;
  padding: 0.35rem 1rem;
  border: 1px solid var(--rule);
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  white-space: nowrap;
}

.publish-card-btn:hover {
  border-color: var(--link);
  color: var(--link);
}

.publish-card-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.publish-card-status {
  font-family: var(--mono);
  font-size: 0.7rem;
  color: var(--muted);
  margin-top: 0.4rem;
}

.publish-card-status.error {
  color: var(--link);
}

.rescan-offer {
  margin-top: 2rem;
  font-family: var(--mono);
  font-size: 0.75rem;
  color: var(--muted);
}

footer {
  margin-top: 4rem;
  font-family: var(--mono);
  font-size: 0.7rem;
  color: var(--muted);
  letter-spacing: 0.05em;
}

footer a {
  color: var(--muted);
  text-decoration: none;
}

footer a:hover {
  color: var(--text);
}

/* --- Seek --- */
.seek-offer {
  margin-top: 1rem;
  font-family: var(--mono);
  font-size: 0.75rem;
  color: var(--muted);
}

.seek-btn {
  font-family: var(--mono);
  font-size: 0.75rem;
  letter-spacing: 0.05em;
  padding: 0.5rem 1.25rem;
  border: 1px solid var(--rule);
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
}

.seek-btn:hover {
  border-color: var(--link);
  color: var(--link);
}

.seek-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.seek-section {
  margin-top: 3rem;
  padding-top: 2rem;
  border-top: 1px solid var(--rule);
}

.seek-controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1rem 2rem;
  margin-bottom: 2rem;
}

.seek-control {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.seek-control > label {
  font-family: var(--mono);
  font-size: 0.65rem;
  color: var(--muted);
  letter-spacing: 0.05em;
}

.seek-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.seek-slider {
  flex: 1;
  -webkit-appearance: none;
  appearance: none;
  height: 1px;
  background: var(--rule);
  outline: none;
}

.seek-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: var(--text);
  cursor: pointer;
}

.seek-slider::-moz-range-thumb {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  border: none;
  background: var(--text);
  cursor: pointer;
}

.seek-val {
  font-family: var(--mono);
  font-size: 0.7rem;
  color: var(--text);
  min-width: 3rem;
  text-align: right;
}

.seek-select {
  font-family: var(--mono);
  font-size: 0.7rem;
  padding: 0.25rem 0.4rem;
  border: 1px solid var(--rule);
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  width: 100%;
}

.seek-select:focus {
  outline: none;
  border-color: var(--link);
}

.seek-toggle label {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  font-family: var(--mono);
  font-size: 0.7rem;
  color: var(--text);
  cursor: pointer;
  padding-top: 0.5rem;
}

.seek-toggle input[type="checkbox"] {
  accent-color: var(--link);
}

.seek-meta-stats {
  font-family: var(--mono);
  font-size: 0.65rem;
  color: var(--muted);
  margin-top: 0.15rem;
}

@media (max-width: 480px) {
  .seek-controls {
    grid-template-columns: 1fr;
  }
}

.hidden { display: none !important; }
</style>
</head>
<body>

<h1><a href="/">mino.mobi</a> / cluster</h1>

<p class="subtitle">Find your tightest circles.</p>

<p class="desc">
  Enter your Bluesky handle to find the largest groups of your follows
  who all mutually follow each other. Gold, silver, bronze&mdash;then
  shells peeling outward from each until they meld.
</p>

<form class="handle-form" id="handleForm">
  <input type="text" id="handleInput" placeholder="handle.bsky.social" autocomplete="off" spellcheck="false">
  <button type="submit" id="loadBtn">cluster</button>
</form>

<div class="progress-track hidden" id="progressBar">
  <div class="progress-fill" id="progressFill"></div>
</div>

<div class="status-line hidden" id="status"></div>
<div class="graph-stats hidden" id="graphStats"></div>

<div id="graphContainer" class="hidden"></div>

<div id="results"></div>

<div id="rescanOffer" class="rescan-offer hidden">
  <button class="rescan-btn" id="rescanBtn">full rescan</button>
  &mdash; recompute cliques from scratch (slower)
</div>

<div id="seekOffer" class="seek-offer hidden">
  <button class="seek-btn" id="seekBtn">seek</button>
  &mdash; discover accounts your cluster follows that you don't
</div>

<div id="seekSection" class="seek-section hidden">
  <div class="section-header">seek &middot; <span id="seekCount">0</span> accounts</div>
  <div class="seek-controls">
    <div class="seek-control">
      <label>min core following</label>
      <div class="seek-row">
        <input type="range" class="seek-slider" id="seekMinCore" min="2" max="20" value="2">
        <span class="seek-val" id="seekMinCoreVal">2</span>
      </div>
    </div>
    <div class="seek-control">
      <label>max follows</label>
      <div class="seek-row">
        <input type="range" class="seek-slider" id="seekMaxFollows" min="100" max="5000" value="2000" step="100">
        <span class="seek-val" id="seekMaxFollowsVal">2K</span>
      </div>
    </div>
    <div class="seek-control">
      <label>min followers</label>
      <div class="seek-row">
        <input type="range" class="seek-slider" id="seekMinFollowers" min="0" max="1000" value="10" step="10">
        <span class="seek-val" id="seekMinFollowersVal">10</span>
      </div>
    </div>
    <div class="seek-control seek-toggle">
      <label><input type="checkbox" id="seekActive" checked> active &le; 30d</label>
    </div>
    <div class="seek-control">
      <label>sort by</label>
      <select class="seek-select" id="seekSort">
        <option value="core">core members</option>
        <option value="followers">followers</option>
        <option value="recent">recent activity</option>
      </select>
    </div>
  </div>
  <div id="seekStatus" class="status-line hidden"></div>
  <div id="seekProgress" class="progress-track hidden">
    <div class="progress-fill" id="seekProgressFill"></div>
  </div>
  <div id="seekResults"></div>
</div>

<div id="publishSection" class="publish-section hidden">
  <div class="section-header">publish as lists</div>
  <p class="publish-desc">
    Save clusters to your Bluesky account as curated lists.
    Control shell depth per cluster&mdash;tight core or wide orbit.
    Requires an <a href="https://bsky.app/settings/app-passwords" target="_blank" rel="noopener">app password</a>.
  </p>
  <div class="auth-form" id="authForm">
    <input type="text" id="authHandle" placeholder="your-handle.bsky.social" autocomplete="username">
    <input type="password" id="authPassword" placeholder="app password" autocomplete="current-password">
  </div>
  <div id="publishCards"></div>
</div>

<footer>
  <a href="/">mino.mobi</a> &middot;
  <a href="https://bsky.app/profile/mino.mobi">@mino.mobi</a>
</footer>

<script>
(function () {
  const PUBLIC_API = 'https://public.api.bsky.app';
  const COLORS = { gold: '#daa520', silver: '#8898a8', bronze: '#b87333' };
  const MIN_CLIQUE = 5;
  const MAX_GRAPH_NODES = 150;

  // --- State ---
  let currentCliques = [];
  let currentProfileMap = new Map();
  let seekState = null;   // { coreDids, coreFollows, myFollowDids, myDid }
  let seekCandidates = []; // enriched candidate list

  // --- Worker acceleration ---
  // Pages Function at /cluster-batch — auto-deploys from functions/ dir.
  // Falls back to direct browser fetching if unavailable.
  const WORKER_URL = '/cluster-batch';
  const WORKER_BATCH = 10;    // DIDs per request (free tier: 50 subrequest limit)
  const WORKER_PARALLEL = 4;  // concurrent requests
  let useWorker = !!WORKER_URL;

  async function batchFetchFollows(dids, onProgress) {
    if (!useWorker) return null;
    const batches = [];
    for (let i = 0; i < dids.length; i += WORKER_BATCH) {
      batches.push(dids.slice(i, i + WORKER_BATCH));
    }
    const allFollows = new Map();
    const allProfiles = new Map();
    let done = 0;
    try {
      const retryDids = [];
      await mapConcurrent(batches, WORKER_PARALLEL, async (batch) => {
        const res = await fetch(WORKER_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ dids: batch })
        });
        if (!res.ok) throw new Error(`Worker ${res.status}`);
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        for (const [did, arr] of Object.entries(data.follows)) {
          allFollows.set(did, new Set(arr));
        }
        for (const [did, profile] of Object.entries(data.profiles)) {
          if (!allProfiles.has(did)) allProfiles.set(did, profile);
        }
        if (data.failed) retryDids.push(...data.failed);
        done += batch.length;
        if (onProgress) onProgress(Math.min(done, dids.length));
      });
      // Retry rate-limited DIDs via direct browser fetch (different IP)
      if (retryDids.length > 0) {
        console.log(`Retrying ${retryDids.length} rate-limited DIDs via browser`);
        await mapConcurrent(retryDids, 3, async (did) => {
          try {
            const follows = await getAllFollows(did);
            allFollows.set(did, new Set(follows.map(f => f.did)));
            for (const f of follows) {
              if (!allProfiles.has(f.did)) allProfiles.set(f.did, {
                handle: f.handle,
                displayName: f.displayName || '',
                avatar: f.avatar || '',
              });
            }
          } catch {
            allFollows.set(did, new Set());
          }
        });
      }
      return { follows: allFollows, profiles: allProfiles };
    } catch {
      useWorker = false;
      return null;
    }
  }

  // --- Identity resolution ---

  async function resolveHandle(handle) {
    const res = await fetch(
      `${PUBLIC_API}/xrpc/com.atproto.identity.resolveHandle?handle=${encodeURIComponent(handle)}`
    );
    if (!res.ok) throw new Error(`Could not resolve handle: ${handle}`);
    return (await res.json()).did;
  }

  async function resolvePDS(did) {
    let doc;
    if (did.startsWith('did:plc:')) {
      const res = await fetch(`https://plc.directory/${did}`);
      if (!res.ok) throw new Error(`Could not resolve DID: ${did}`);
      doc = await res.json();
    } else if (did.startsWith('did:web:')) {
      const host = did.slice('did:web:'.length).replaceAll(':', '/');
      const res = await fetch(`https://${host}/.well-known/did.json`);
      if (!res.ok) throw new Error(`Could not resolve DID: ${did}`);
      doc = await res.json();
    } else {
      throw new Error(`Unsupported DID method: ${did}`);
    }
    const svc = doc.service?.find(s => s.type === 'AtprotoPersonalDataServer');
    if (!svc) throw new Error('No PDS endpoint found');
    return svc.serviceEndpoint;
  }

  // --- API helpers ---

  async function fetchJSON(url, retries = 3) {
    for (let i = 0; i <= retries; i++) {
      const res = await fetch(url);
      if (res.status === 429) {
        await new Promise(r => setTimeout(r, Math.pow(2, i) * 1000));
        continue;
      }
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }
    throw new Error('Rate limited');
  }

  async function getAllFollows(actor, onProgress) {
    const follows = [];
    let cursor;
    do {
      const params = new URLSearchParams({ actor, limit: '100' });
      if (cursor) params.set('cursor', cursor);
      const data = await fetchJSON(
        `${PUBLIC_API}/xrpc/app.bsky.graph.getFollows?${params}`
      );
      follows.push(...(data.follows || []));
      cursor = data.cursor;
      if (onProgress) onProgress(follows.length);
    } while (cursor);
    return follows;
  }

  async function mapConcurrent(items, concurrency, fn) {
    let index = 0;
    async function worker() {
      while (index < items.length) {
        const i = index++;
        await fn(items[i], i);
      }
    }
    await Promise.all(Array.from({ length: concurrency }, () => worker()));
  }

  // --- List detection (uses AppView endpoint, not com.atproto) ---

  async function findClusterList(actor) {
    try {
      let cursor, best = null;
      do {
        const params = new URLSearchParams({ actor, limit: '100' });
        if (cursor) params.set('cursor', cursor);
        const data = await fetchJSON(
          `${PUBLIC_API}/xrpc/app.bsky.graph.getLists?${params}`
        );
        for (const list of (data.lists || [])) {
          if (list.description?.includes('mino.mobi/cluster')) best = list.uri;
        }
        cursor = data.cursor;
      } while (cursor);
      return best;
    } catch { return null; }
  }

  async function getListMembers(listUri) {
    const members = [];
    let cursor;
    do {
      const params = new URLSearchParams({ list: listUri, limit: '100' });
      if (cursor) params.set('cursor', cursor);
      const data = await fetchJSON(
        `${PUBLIC_API}/xrpc/app.bsky.graph.getList?${params}`
      );
      for (const item of (data.items || [])) members.push(item.subject);
      cursor = data.cursor;
    } while (cursor);
    return members;
  }

  // --- Bron-Kerbosch with pivot and pruning ---

  function findMaxClique(adj, nodeList) {
    let best = [];
    let ops = 0;
    const LIMIT = 5_000_000;

    function neighborsInSet(v, s) {
      let c = 0;
      const n = adj.get(v);
      if (!n) return 0;
      for (const u of n) if (s.has(u)) c++;
      return c;
    }

    function bk(clique, P, X) {
      if (ops++ > LIMIT) return;
      if (P.size === 0 && X.size === 0) {
        if (clique.length > best.length) best = [...clique];
        return;
      }
      if (clique.length + P.size <= best.length) return;

      let pivot = null, maxN = -1;
      for (const v of P) {
        const n = neighborsInSet(v, P);
        if (n > maxN) { pivot = v; maxN = n; }
      }
      for (const v of X) {
        const n = neighborsInSet(v, P);
        if (n > maxN) { pivot = v; maxN = n; }
      }

      const pivotN = adj.get(pivot) || new Set();
      const candidates = [];
      for (const v of P) if (!pivotN.has(v)) candidates.push(v);

      for (const v of candidates) {
        if (ops > LIMIT) return;
        const vN = adj.get(v) || new Set();
        const newP = new Set();
        const newX = new Set();
        for (const u of P) if (vN.has(u)) newP.add(u);
        for (const u of X) if (vN.has(u)) newX.add(u);

        clique.push(v);
        bk(clique, newP, newX);
        clique.pop();

        P.delete(v);
        X.add(v);
      }
    }

    bk([], new Set(nodeList), new Set());
    return { clique: best, exhaustive: ops <= LIMIT };
  }

  // --- Shell peeling from a clique using a mutual adjacency map ---

  function shellPeel(coreDids, mutual, minThreshold) {
    const coreSet = new Set(coreDids);
    const coreSize = coreDids.length;
    const shells = [];
    const assigned = new Set(coreDids);
    const floor = Math.max(minThreshold, Math.ceil(coreSize / 2));

    for (let t = coreSize - 1; t >= floor; t--) {
      const layer = [];
      for (const [node, neighbors] of mutual) {
        if (assigned.has(node)) continue;
        let count = 0;
        for (const c of coreDids) if (neighbors.has(c)) count++;
        if (count >= t) layer.push({ did: node, count });
      }
      if (layer.length === 0) continue;
      layer.sort((a, b) => b.count - a.count);
      for (const m of layer) assigned.add(m.did);
      shells.push({ threshold: t, members: layer });
    }
    return shells;
  }

  // --- Bridge detection: nodes appearing in multiple cliques' shells ---

  function detectBridges(cliques) {
    const seen = new Map(); // did → first clique label
    const bridges = new Map(); // did → Set of clique labels
    for (const c of cliques) {
      const label = c.label;
      for (const did of c.core) {
        if (seen.has(did) && seen.get(did) !== label) {
          if (!bridges.has(did)) bridges.set(did, new Set([seen.get(did)]));
          bridges.get(did).add(label);
        }
        if (!seen.has(did)) seen.set(did, label);
      }
      for (const sh of c.shells) {
        for (const m of sh.members) {
          if (seen.has(m.did) && seen.get(m.did) !== label) {
            if (!bridges.has(m.did)) bridges.set(m.did, new Set([seen.get(m.did)]));
            bridges.get(m.did).add(label);
          }
          if (!seen.has(m.did)) seen.set(m.did, label);
        }
      }
    }
    return bridges;
  }

  // --- Rendering ---

  function escapeHtml(str) {
    const el = document.createElement('span');
    el.textContent = str || '';
    return el.innerHTML;
  }

  function renderPersonRow(did, profileMap, meta) {
    const p = profileMap.get(did) || {};
    const handle = escapeHtml(p.handle || did);
    const name = escapeHtml(p.displayName || p.handle || did);
    const url = p.handle
      ? `https://bsky.app/profile/${encodeURIComponent(p.handle)}`
      : '#';
    const avatar = p.avatar || '';

    return `<div class="result-row">
      ${avatar
        ? `<img class="pfp" src="${escapeHtml(avatar)}" alt="" loading="lazy">`
        : `<div class="pfp"></div>`}
      <div class="result-info">
        <a class="result-handle" href="${url}" target="_blank" rel="noopener">@${handle}</a>
        <div class="result-name">${name}</div>
      </div>
      ${meta ? `<div class="result-meta">${meta}</div>` : ''}
    </div>`;
  }

  function renderResults(cliques, bridges, profileMap) {
    const results = document.getElementById('results');
    const multi = cliques.filter(c => c.core.length > 0).length > 1;
    let html = '';

    for (const c of cliques) {
      if (c.core.length === 0) continue;
      const prefix = multi ? `${c.label} ` : '';
      const coreSize = c.core.length;

      // Core
      html += `<div class="shell-section">`;
      html += `<div class="section-header">${prefix}core \u00b7 ${coreSize} people</div>`;
      html += c.core.map(did => {
        const b = bridges.get(did);
        const tag = b ? ` \u00b7 also ${[...b].filter(l => l !== c.label).join(', ')}` : '';
        return renderPersonRow(did, profileMap, tag || '');
      }).join('');
      html += `</div>`;

      // Shells
      for (let i = 0; i < c.shells.length; i++) {
        const sh = c.shells[i];
        const shellLabel = multi ? `${c.label} shell ${i + 1}` : `shell ${i + 1}`;
        html += `<div class="shell-section">`;
        html += `<div class="section-header">${shellLabel} \u00b7 ${sh.members.length} people \u00b7 ${sh.threshold}/${coreSize} mutual</div>`;
        html += sh.members.map(m => {
          const b = bridges.get(m.did);
          const tag = b ? `also ${[...b].filter(l => l !== c.label).join(', ')}` : '';
          const meta = `${m.count}/${coreSize}${tag ? '<br>' + tag : ''}`;
          return renderPersonRow(m.did, profileMap, meta);
        }).join('');
        html += `</div>`;
      }
    }

    if (html === '') {
      html = '<div class="empty-state">No mutual clique found among your follows.</div>';
    }

    results.innerHTML = html;
  }

  // --- Force-directed graph ---

  function createForceGraph(container, cliques, bridges, hasEdge, profileMap) {
    container.innerHTML = '';
    container.classList.remove('hidden');

    // Collect displayed nodes
    const nodes = [];
    const nodeIndex = new Map();
    const addedDids = new Set();

    for (const c of cliques) {
      if (c.core.length === 0) continue;
      for (const did of c.core) {
        if (addedDids.has(did)) continue;
        addedDids.add(did);
        nodeIndex.set(did, nodes.length);
        nodes.push({ id: did, clique: c.label, layer: 0 });
      }
      for (let si = 0; si < c.shells.length; si++) {
        for (const m of c.shells[si].members) {
          if (addedDids.has(m.did)) continue;
          addedDids.add(m.did);
          nodeIndex.set(m.did, nodes.length);
          nodes.push({ id: m.did, clique: c.label, layer: si + 1 });
        }
        if (nodes.length >= MAX_GRAPH_NODES) break;
      }
      if (nodes.length >= MAX_GRAPH_NODES) break;
    }

    if (nodes.length < 3) { container.classList.add('hidden'); return; }

    // Build edges
    const edges = [];
    const dids = nodes.map(n => n.id);
    for (let i = 0; i < dids.length; i++) {
      for (let j = i + 1; j < dids.length; j++) {
        if (hasEdge(dids[i], dids[j])) edges.push([i, j]);
      }
    }

    // Canvas setup
    const canvas = document.createElement('canvas');
    const w = container.clientWidth || 720;
    const h = Math.round(w * 0.6);
    const dpr = window.devicePixelRatio || 1;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    container.appendChild(canvas);

    // Read theme colors
    const cs = getComputedStyle(document.documentElement);
    const bgColor = cs.getPropertyValue('--bg').trim();
    const textColor = cs.getPropertyValue('--text').trim();
    const ruleColor = cs.getPropertyValue('--rule').trim();
    const monoFont = cs.getPropertyValue('--mono').trim();

    // Assign node visual properties
    const activeCliques = [...new Set(cliques.filter(c => c.core.length > 0).map(c => c.label))];
    const offsets = {};
    if (activeCliques.length === 1) {
      offsets[activeCliques[0]] = { x: 0, y: 0 };
    } else {
      const step = (Math.PI * 2) / activeCliques.length;
      activeCliques.forEach((label, i) => {
        offsets[label] = {
          x: Math.cos(i * step - Math.PI / 2) * 0.2,
          y: Math.sin(i * step - Math.PI / 2) * 0.2
        };
      });
    }

    for (const node of nodes) {
      const off = offsets[node.clique] || { x: 0, y: 0 };
      node.x = w * (0.5 + off.x) + (Math.random() - 0.5) * 80;
      node.y = h * (0.5 + off.y) + (Math.random() - 0.5) * 80;
      node.vx = 0;
      node.vy = 0;
      node.radius = Math.max(3, 5.5 - node.layer * 0.7);
      const base = COLORS[node.clique] || COLORS.gold;
      const alpha = Math.max(0.45, 0.9 - node.layer * 0.15);
      node.color = base;
      node.alpha = alpha;
      node.isBridge = bridges.has(node.id);
    }

    // Precompute edge lookup for same-clique attraction boost
    const edgeSet = new Set();
    for (const [i, j] of edges) edgeSet.add(`${i}:${j}`);

    // Simulation
    let hoveredNode = null;
    let running = true;
    let ticks = 0;

    function tick() {
      // Center gravity
      for (const node of nodes) {
        node.vx += (w / 2 - node.x) * 0.0008;
        node.vy += (h / 2 - node.y) * 0.0008;
      }

      // Repulsion
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const a = nodes[i], b = nodes[j];
          let dx = b.x - a.x, dy = b.y - a.y;
          const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 1);
          const force = 600 / (dist * dist);
          const fx = force * dx / dist, fy = force * dy / dist;
          a.vx -= fx; a.vy -= fy;
          b.vx += fx; b.vy += fy;
        }
      }

      // Edge attraction
      for (const [i, j] of edges) {
        const s = nodes[i], t = nodes[j];
        const dx = t.x - s.x, dy = t.y - s.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 1) continue;
        const force = (dist - 50) * 0.004;
        const fx = force * dx / dist, fy = force * dy / dist;
        s.vx += fx; s.vy += fy;
        t.vx -= fx; t.vy -= fy;
      }

      // Same-clique cohesion (gentle)
      if (activeCliques.length > 1) {
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            if (nodes[i].clique !== nodes[j].clique) continue;
            const dx = nodes[j].x - nodes[i].x, dy = nodes[j].y - nodes[i].y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 1) continue;
            const force = dist * 0.0003;
            const fx = force * dx / dist, fy = force * dy / dist;
            nodes[i].vx += fx; nodes[i].vy += fy;
            nodes[j].vx -= fx; nodes[j].vy -= fy;
          }
        }
      }

      // Update positions
      let energy = 0;
      for (const node of nodes) {
        node.vx *= 0.85;
        node.vy *= 0.85;
        node.x += node.vx;
        node.y += node.vy;
        node.x = Math.max(16, Math.min(w - 16, node.x));
        node.y = Math.max(16, Math.min(h - 16, node.y));
        energy += node.vx * node.vx + node.vy * node.vy;
      }

      ticks++;
      return energy;
    }

    function draw() {
      ctx.clearRect(0, 0, w, h);

      // Edges
      ctx.strokeStyle = ruleColor;
      ctx.lineWidth = 0.5;
      ctx.globalAlpha = 0.1;
      for (const [i, j] of edges) {
        ctx.beginPath();
        ctx.moveTo(nodes[i].x, nodes[i].y);
        ctx.lineTo(nodes[j].x, nodes[j].y);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // Nodes
      for (const node of nodes) {
        // Bridge ring
        if (node.isBridge) {
          ctx.beginPath();
          ctx.arc(node.x, node.y, node.radius + 2.5, 0, Math.PI * 2);
          ctx.strokeStyle = textColor;
          ctx.globalAlpha = 0.4;
          ctx.lineWidth = 1.5;
          ctx.stroke();
          ctx.globalAlpha = 1;
        }

        ctx.beginPath();
        ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
        ctx.fillStyle = node.color;
        ctx.globalAlpha = node === hoveredNode ? 1 : node.alpha;
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      // Hovered label
      if (hoveredNode) {
        const p = profileMap.get(hoveredNode.id);
        const label = '@' + (p?.handle || hoveredNode.id.slice(0, 16));
        ctx.font = `11px ${monoFont}`;
        ctx.textAlign = 'center';
        const tw = ctx.measureText(label).width;
        const lx = hoveredNode.x, ly = hoveredNode.y - hoveredNode.radius - 10;

        ctx.fillStyle = bgColor;
        ctx.globalAlpha = 0.85;
        ctx.fillRect(lx - tw / 2 - 4, ly - 10, tw + 8, 16);
        ctx.globalAlpha = 1;
        ctx.fillStyle = textColor;
        ctx.fillText(label, lx, ly + 2);
      }
    }

    function animate() {
      const energy = tick();
      draw();
      if (energy > 0.05 && ticks < 600) {
        requestAnimationFrame(animate);
      } else {
        running = false;
        draw();
      }
    }

    // Interaction
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (w / rect.width);
      const my = (e.clientY - rect.top) * (h / rect.height);
      hoveredNode = null;
      for (const node of nodes) {
        const dx = mx - node.x, dy = my - node.y;
        if (dx * dx + dy * dy < (node.radius + 5) * (node.radius + 5)) {
          hoveredNode = node;
          break;
        }
      }
      canvas.style.cursor = hoveredNode ? 'pointer' : 'default';
      if (!running) draw();
    });

    canvas.addEventListener('mouseleave', () => {
      hoveredNode = null;
      if (!running) draw();
    });

    canvas.addEventListener('click', () => {
      if (hoveredNode) {
        const p = profileMap.get(hoveredNode.id);
        if (p?.handle) window.open(`https://bsky.app/profile/${p.handle}`, '_blank');
      }
    });

    animate();
  }

  // --- Fast path: shell peel from existing cluster list ---

  async function fastPath(did, raw, status, progressFill, graphStats) {
    status.textContent = 'checking for cluster list\u2026';
    const listUri = await findClusterList(raw);
    if (!listUri) return false;

    status.textContent = 'loading cluster list\u2026';
    const members = await getListMembers(listUri);
    if (members.length === 0) return false;

    const coreDids = members.map(m => m.did);
    const coreSet = new Set(coreDids);
    const coreSize = members.length;
    currentProfileMap = new Map();
    for (const m of members) currentProfileMap.set(m.did, m);

    // Phase 1: fetch follows for each core member
    const allFollows = new Map();
    const memberDids = members.map(m => m.did);
    const batch1 = await batchFetchFollows(memberDids, (n) => {
      status.textContent = `scanning core follows\u2026 ${n}/${coreSize}`;
      progressFill.style.width = (n / coreSize * 50) + '%';
    });

    if (batch1) {
      for (const [did, profile] of batch1.profiles) {
        if (!currentProfileMap.has(did)) currentProfileMap.set(did, profile);
      }
      for (const m of members) {
        allFollows.set(m.did, batch1.follows.get(m.did) || new Set());
      }
    } else {
      let scanned = 0;
      await mapConcurrent(members, 5, async (member) => {
        try {
          const follows = await getAllFollows(member.did);
          allFollows.set(member.did, new Set(follows.map(f => f.did)));
          for (const f of follows) {
            if (!currentProfileMap.has(f.did)) currentProfileMap.set(f.did, f);
          }
        } catch {
          allFollows.set(member.did, new Set());
        }
        scanned++;
        status.textContent = `scanning core follows\u2026 ${scanned}/${coreSize}`;
        progressFill.style.width = (scanned / coreSize * 50) + '%';
      });
    }

    // Count: for each non-member, how many core members follow them
    const followedBy = new Map();
    for (const [, follows] of allFollows) {
      for (const d of follows) {
        if (coreSet.has(d)) continue;
        followedBy.set(d, (followedBy.get(d) || 0) + 1);
      }
    }

    const minThreshold = Math.max(MIN_CLIQUE, Math.ceil(coreSize / 2));
    const candidateDids = [...followedBy.entries()]
      .filter(([, count]) => count >= minThreshold)
      .sort((a, b) => b[1] - a[1])
      .map(([d]) => d);

    // Phase 2: fetch candidates' follows for reciprocity
    if (candidateDids.length > 0) {
      const batch2 = await batchFetchFollows(candidateDids, (n) => {
        status.textContent = `verifying candidates\u2026 ${n}/${candidateDids.length}`;
        progressFill.style.width = (50 + n / candidateDids.length * 50) + '%';
      });

      if (batch2) {
        for (const [did, profile] of batch2.profiles) {
          if (!currentProfileMap.has(did)) currentProfileMap.set(did, profile);
        }
        for (const d of candidateDids) {
          allFollows.set(d, batch2.follows.get(d) || new Set());
        }
      } else {
        let verified = 0;
        await mapConcurrent(candidateDids, 5, async (d) => {
          try {
            const follows = await getAllFollows(d);
            allFollows.set(d, new Set(follows.map(f => f.did)));
          } catch {
            allFollows.set(d, new Set());
          }
          verified++;
          status.textContent = `verifying candidates\u2026 ${verified}/${candidateDids.length}`;
          progressFill.style.width = (50 + verified / candidateDids.length * 50) + '%';
        });
      }
    }

    // Build mutual adjacency from collected follow data for shell peeling
    const displayPool = new Set([...coreDids, ...candidateDids]);
    const mutual = new Map();
    for (const a of displayPool) {
      const aF = allFollows.get(a);
      if (!aF) continue;
      const m = new Set();
      for (const b of displayPool) {
        if (b === a) continue;
        if (aF.has(b) && allFollows.get(b)?.has(a)) m.add(b);
      }
      if (m.size > 0) mutual.set(a, m);
    }

    const shells = shellPeel(coreDids, mutual, MIN_CLIQUE);

    const cliques = [{ label: 'gold', core: coreDids, shells }];
    const bridges = detectBridges(cliques);

    // Stats
    const totalShell = shells.reduce((s, sh) => s + sh.members.length, 0);
    graphStats.innerHTML =
      `cluster list \u00b7 ${coreSize} core \u2192 ${candidateDids.length} candidates \u2192 ${shells.length} shells (${totalShell} people)`;
    graphStats.classList.remove('hidden');
    status.textContent = `done \u00b7 ${coreSize} core + ${totalShell} in ${shells.length} shells`;
    progressFill.style.width = '100%';

    // Render
    renderResults(cliques, bridges, currentProfileMap);

    const hasEdge = (a, b) => mutual.get(a)?.has(b) || false;
    createForceGraph(document.getElementById('graphContainer'),
      cliques, bridges, hasEdge, currentProfileMap);

    currentCliques = cliques;

    // Save seek state — fastPath has core follows already
    seekState = {
      coreDids,
      coreFollows: allFollows,
      myFollowDids: null, // fetched lazily when seek activates
      myDid: did,
    };

    document.getElementById('rescanOffer').classList.remove('hidden');
    document.getElementById('seekOffer').classList.remove('hidden');
    return true;
  }

  // --- Full path: scan all follows, multi-clique, shell peel ---

  async function fullPath(did, status, progressFill, graphStats) {
    status.textContent = 'fetching your follows\u2026';
    const myFollows = await getAllFollows(did, (n) => {
      status.textContent = `fetching your follows\u2026 ${n}`;
    });

    const myFollowDids = new Set(myFollows.map(f => f.did));
    currentProfileMap = new Map();
    for (const f of myFollows) currentProfileMap.set(f.did, f);

    // Build directed adjacency
    const directed = new Map();
    const followDids = myFollows.map(f => f.did);
    const batch = await batchFetchFollows(followDids, (n) => {
      status.textContent = `scanning follows\u2026 ${n}/${myFollows.length}`;
      progressFill.style.width = (n / myFollows.length * 100) + '%';
    });

    if (batch) {
      for (const [did, profile] of batch.profiles) {
        if (!currentProfileMap.has(did)) currentProfileMap.set(did, profile);
      }
      for (const did of followDids) {
        const theirFollows = batch.follows.get(did) || new Set();
        const overlap = new Set();
        for (const f of theirFollows) {
          if (myFollowDids.has(f) && f !== did) overlap.add(f);
        }
        directed.set(did, overlap);
      }
    } else {
      let scanned = 0;
      await mapConcurrent(myFollows, 5, async (follow) => {
        try {
          const theirFollows = await getAllFollows(follow.did);
          const overlap = new Set();
          for (const f of theirFollows) {
            if (myFollowDids.has(f.did) && f.did !== follow.did) overlap.add(f.did);
          }
          directed.set(follow.did, overlap);
        } catch {
          directed.set(follow.did, new Set());
        }
        scanned++;
        status.textContent = `scanning follows\u2026 ${scanned}/${myFollows.length}`;
        progressFill.style.width = (scanned / myFollows.length * 100) + '%';
      });
    }

    // Build mutual adjacency
    status.textContent = 'building mutual graph\u2026';
    const mutual = new Map();
    let mutualEdges = 0;
    for (const [a, aFollows] of directed) {
      const m = new Set();
      for (const b of aFollows) {
        if (directed.get(b)?.has(a)) m.add(b);
      }
      if (m.size > 0) mutual.set(a, m);
      mutualEdges += m.size;
    }
    mutualEdges /= 2;

    const mutualNodes = [...mutual.keys()];
    graphStats.innerHTML =
      `${myFollows.length} follows \u2192 ${mutualNodes.length} with mutual connections \u2192 ${Math.round(mutualEdges)} mutual edges`;
    graphStats.classList.remove('hidden');

    // --- Find gold / silver / bronze cliques ---
    status.textContent = 'computing gold clique\u2026';
    progressFill.style.width = '100%';
    await new Promise(r => setTimeout(r, 50));

    const gold = findMaxClique(mutual, mutualNodes);
    const goldSet = new Set(gold.clique);

    let silver = { clique: [], exhaustive: true };
    let silverSet = new Set();
    if (gold.clique.length >= MIN_CLIQUE) {
      status.textContent = 'computing silver clique\u2026';
      await new Promise(r => setTimeout(r, 20));
      const silverPool = mutualNodes.filter(n => !goldSet.has(n));
      silver = findMaxClique(mutual, silverPool);
      silverSet = new Set(silver.clique);
    }

    let bronze = { clique: [], exhaustive: true };
    if (silver.clique.length >= MIN_CLIQUE) {
      status.textContent = 'computing bronze clique\u2026';
      await new Promise(r => setTimeout(r, 20));
      const bronzePool = mutualNodes.filter(n => !goldSet.has(n) && !silverSet.has(n));
      bronze = findMaxClique(mutual, bronzePool);
    }

    // Shell peel each clique
    status.textContent = 'peeling shells\u2026';
    const cliques = [];

    if (gold.clique.length > 0) {
      cliques.push({
        label: 'gold',
        core: gold.clique,
        shells: shellPeel(gold.clique, mutual, MIN_CLIQUE)
      });
    }
    if (silver.clique.length >= MIN_CLIQUE) {
      cliques.push({
        label: 'silver',
        core: silver.clique,
        shells: shellPeel(silver.clique, mutual, MIN_CLIQUE)
      });
    }
    if (bronze.clique.length >= MIN_CLIQUE) {
      cliques.push({
        label: 'bronze',
        core: bronze.clique,
        shells: shellPeel(bronze.clique, mutual, MIN_CLIQUE)
      });
    }

    const bridges = detectBridges(cliques);

    // Status summary
    const parts = [];
    for (const c of cliques) {
      const shellCount = c.shells.reduce((s, sh) => s + sh.members.length, 0);
      parts.push(`${c.label} ${c.core.length}${shellCount > 0 ? `+${shellCount}` : ''}`);
    }
    const bridgeCount = bridges.size;
    status.textContent = `done \u00b7 ${parts.join(' \u00b7 ')}${bridgeCount > 0 ? ` \u00b7 ${bridgeCount} bridges` : ''}`;

    // Render
    renderResults(cliques, bridges, currentProfileMap);

    const hasEdge = (a, b) => mutual.get(a)?.has(b) || false;
    createForceGraph(document.getElementById('graphContainer'),
      cliques, bridges, hasEdge, currentProfileMap);

    currentCliques = cliques;

    // Save seek state — extract core follows from batch if available
    const seekCoreDids = cliques.flatMap(c => c.core);
    let seekCoreFollows = null;
    if (batch) {
      seekCoreFollows = new Map();
      for (const d of seekCoreDids) {
        seekCoreFollows.set(d, batch.follows.get(d) || new Set());
      }
    }
    seekState = {
      coreDids: seekCoreDids,
      coreFollows: seekCoreFollows,
      myFollowDids,
      myDid: did,
    };
    document.getElementById('seekOffer').classList.remove('hidden');
  }

  // --- Seek: discover accounts your cluster follows that you don't ---

  const SEEK_URL = '/seek-profiles';
  const SEEK_BATCH = 25;
  const SEEK_PARALLEL = 4;
  const SEEK_MAX = 200;

  function timeAgo(iso) {
    if (!iso) return null;
    const ms = Date.now() - new Date(iso).getTime();
    const d = Math.floor(ms / 86400000);
    if (d < 1) return 'today';
    if (d === 1) return '1d';
    if (d < 30) return d + 'd';
    if (d < 365) return Math.floor(d / 30) + 'mo';
    return Math.floor(d / 365) + 'y';
  }

  function fmtNum(n) {
    if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
    if (n >= 10000) return Math.round(n / 1000) + 'K';
    if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
    return String(n);
  }

  async function runSeek() {
    const status = document.getElementById('seekStatus');
    const progressBar = document.getElementById('seekProgress');
    const progressFill = document.getElementById('seekProgressFill');
    status.classList.remove('hidden');
    progressBar.classList.remove('hidden');
    progressFill.style.width = '0%';

    // Ensure we have the user's full follow set (fastPath doesn't have it)
    if (!seekState.myFollowDids) {
      status.textContent = 'fetching your follows\u2026';
      const myFollows = await getAllFollows(seekState.myDid, (n) => {
        status.textContent = 'fetching your follows\u2026 ' + n;
      });
      seekState.myFollowDids = new Set(myFollows.map(f => f.did));
    }

    // Ensure we have core members' follow sets
    if (!seekState.coreFollows) {
      status.textContent = 'fetching core follows\u2026';
      const coreBatch = await batchFetchFollows(seekState.coreDids, (n) => {
        status.textContent = 'fetching core follows\u2026 ' + n + '/' + seekState.coreDids.length;
      });
      seekState.coreFollows = new Map();
      if (coreBatch) {
        for (const did of seekState.coreDids) {
          seekState.coreFollows.set(did, coreBatch.follows.get(did) || new Set());
        }
      } else {
        await mapConcurrent(seekState.coreDids, 5, async (did) => {
          try {
            const follows = await getAllFollows(did);
            seekState.coreFollows.set(did, new Set(follows.map(f => f.did)));
          } catch {
            seekState.coreFollows.set(did, new Set());
          }
        });
      }
    }

    // Compute candidate counts: how many core members follow each non-followed account
    status.textContent = 'computing candidates\u2026';
    const coreSet = new Set(seekState.coreDids);
    const candidateCounts = new Map();
    for (const [, follows] of seekState.coreFollows) {
      for (const d of follows) {
        if (coreSet.has(d) || seekState.myFollowDids.has(d) || d === seekState.myDid) continue;
        candidateCounts.set(d, (candidateCounts.get(d) || 0) + 1);
      }
    }

    const sorted = [...candidateCounts.entries()]
      .filter(([, count]) => count >= 2)
      .sort((a, b) => b[1] - a[1])
      .slice(0, SEEK_MAX);

    if (sorted.length === 0) {
      status.textContent = 'no candidates found';
      progressBar.classList.add('hidden');
      return;
    }

    // Enrich with profile + activity data via seek-profiles function
    const enrichDids = sorted.map(([did]) => did);
    status.textContent = 'enriching ' + enrichDids.length + ' profiles\u2026';

    const enriched = new Map();
    const batches = [];
    for (let i = 0; i < enrichDids.length; i += SEEK_BATCH) {
      batches.push(enrichDids.slice(i, i + SEEK_BATCH));
    }
    let done = 0;
    await mapConcurrent(batches, SEEK_PARALLEL, async (batch) => {
      try {
        const res = await fetch(SEEK_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ dids: batch })
        });
        if (res.ok) {
          const data = await res.json();
          for (const [did, profile] of Object.entries(data.profiles || {})) {
            enriched.set(did, profile);
          }
        }
      } catch { /* fall back to basic profile data */ }
      done += batch.length;
      progressFill.style.width = (Math.min(done, enrichDids.length) / enrichDids.length * 100) + '%';
      status.textContent = 'enriching profiles\u2026 ' + Math.min(done, enrichDids.length) + '/' + enrichDids.length;
    });

    // Build enriched candidate list
    const coreTotal = seekState.coreDids.length;
    seekCandidates = sorted.map(([did, count]) => {
      const profile = enriched.get(did) || currentProfileMap.get(did) || {};
      return {
        did,
        handle: profile.handle || did,
        displayName: profile.displayName || '',
        avatar: profile.avatar || '',
        coreCount: count,
        coreTotal,
        followersCount: profile.followersCount || 0,
        followsCount: profile.followsCount || 0,
        postsCount: profile.postsCount || 0,
        lastPost: profile.lastPost || null,
      };
    });

    status.textContent = 'done \u00b7 ' + seekCandidates.length + ' candidates enriched';
    progressFill.style.width = '100%';

    // Set slider max for core count
    document.getElementById('seekMinCore').max = coreTotal;
    applySeekFilters();
  }

  function applySeekFilters() {
    const minCore = parseInt(document.getElementById('seekMinCore').value);
    const maxFollows = parseInt(document.getElementById('seekMaxFollows').value);
    const minFollowers = parseInt(document.getElementById('seekMinFollowers').value);
    const activeOnly = document.getElementById('seekActive').checked;
    const sortBy = document.getElementById('seekSort').value;

    const now = Date.now();
    const thirtyDays = 30 * 86400000;

    let filtered = seekCandidates.filter(c => {
      if (c.coreCount < minCore) return false;
      if (c.followsCount > maxFollows) return false;
      if (c.followersCount < minFollowers) return false;
      if (activeOnly) {
        if (c.lastPost) {
          if (now - new Date(c.lastPost).getTime() > thirtyDays) return false;
        } else if (c.postsCount === 0) {
          return false;
        }
      }
      return true;
    });

    if (sortBy === 'core') {
      filtered.sort((a, b) => b.coreCount - a.coreCount || b.followersCount - a.followersCount);
    } else if (sortBy === 'followers') {
      filtered.sort((a, b) => b.followersCount - a.followersCount);
    } else if (sortBy === 'recent') {
      filtered.sort((a, b) => {
        const aT = a.lastPost ? new Date(a.lastPost).getTime() : 0;
        const bT = b.lastPost ? new Date(b.lastPost).getTime() : 0;
        return bT - aT;
      });
    }

    document.getElementById('seekCount').textContent = filtered.length;
    renderSeekResults(filtered);
  }

  function renderSeekResults(candidates) {
    const container = document.getElementById('seekResults');
    if (candidates.length === 0) {
      container.innerHTML = '<div class="empty-state">No accounts match these filters. Try adjusting the sliders.</div>';
      return;
    }
    let html = '';
    for (const c of candidates) {
      const ago = timeAgo(c.lastPost);
      const stats = [
        fmtNum(c.followersCount) + ' followers',
        fmtNum(c.followsCount) + ' follows',
        ago,
      ].filter(Boolean).join(' \u00b7 ');
      html += '<div class="result-row">';
      html += '<img class="pfp" src="' + escapeHtml(c.avatar) + '" alt="" loading="lazy" onerror="this.style.display=\'none\'">';
      html += '<div class="result-info">';
      html += '<a class="result-handle" href="https://bsky.app/profile/' + escapeHtml(c.handle) + '" target="_blank" rel="noopener">@' + escapeHtml(c.handle) + '</a>';
      html += '<div class="result-name">' + escapeHtml(c.displayName) + '</div>';
      html += '<div class="seek-meta-stats">' + stats + '</div>';
      html += '</div>';
      html += '<div class="result-meta">' + c.coreCount + '/' + c.coreTotal + '</div>';
      html += '</div>';
    }
    container.innerHTML = html;
  }

  // --- Publish UI builder ---

  // Precompute cumulative DID lists at each shell depth for a clique
  function cliqueSlices(c) {
    const slices = []; // [{label, count, dids}]
    let dids = [...c.core];
    slices.push({ label: `core only \u00b7 ${dids.length}`, count: dids.length, dids: [...dids] });
    for (let i = 0; i < c.shells.length; i++) {
      for (const m of c.shells[i].members) dids.push(m.did);
      const shellLabel = c.shells.length === 1
        ? `+ shell \u00b7 ${dids.length}`
        : `+ shells 1\u2013${i + 1} \u00b7 ${dids.length}`;
      slices.push({ label: shellLabel, count: dids.length, dids: [...dids] });
    }
    return slices;
  }

  function buildPublishUI(cliques) {
    const container = document.getElementById('publishCards');
    container.innerHTML = '';
    const active = cliques.filter(c => c.core.length > 0);
    if (active.length === 0) return;
    const multi = active.length > 1;

    // Per-clique cards
    for (const c of active) {
      const slices = cliqueSlices(c);
      const card = document.createElement('div');
      card.className = 'publish-card';

      const row = document.createElement('div');
      row.className = 'publish-card-row';

      const label = document.createElement('span');
      label.className = 'publish-card-label';
      label.textContent = multi ? c.label : 'cluster';

      const select = document.createElement('select');
      select.className = 'publish-select';
      for (let si = 0; si < slices.length; si++) {
        const opt = document.createElement('option');
        opt.value = si;
        opt.textContent = slices[si].label;
        if (si === slices.length - 1) opt.selected = true;
        select.appendChild(opt);
      }

      const btn = document.createElement('button');
      btn.className = 'publish-card-btn';
      btn.textContent = 'publish';

      const statusEl = document.createElement('div');
      statusEl.className = 'publish-card-status hidden';

      row.append(label, select, btn);
      card.append(row, statusEl);
      container.appendChild(card);

      btn.addEventListener('click', () => {
        const idx = parseInt(select.value);
        const dids = slices[idx].dids;
        const name = multi
          ? `${c.label[0].toUpperCase() + c.label.slice(1)} Cluster (${dids.length})`
          : `Cluster (${dids.length})`;
        publishList(dids, name, btn, statusEl);
      });
    }

    // "All clusters" card if multiple cliques
    if (multi) {
      const maxDepth = Math.max(...active.map(c => c.shells.length));
      const allSlices = [];

      // Depth 0 = cores only
      let coreAll = [];
      for (const c of active) coreAll.push(...c.core);
      coreAll = [...new Set(coreAll)];
      allSlices.push({ label: `cores only \u00b7 ${coreAll.length}`, dids: coreAll });

      // Depth 1..maxDepth
      for (let d = 0; d < maxDepth; d++) {
        let dids = [];
        for (const c of active) {
          dids.push(...c.core);
          for (let si = 0; si <= d && si < c.shells.length; si++) {
            for (const m of c.shells[si].members) dids.push(m.did);
          }
        }
        dids = [...new Set(dids)];
        const shellLabel = maxDepth === 1
          ? `+ all shells \u00b7 ${dids.length}`
          : `+ shells 1\u2013${d + 1} \u00b7 ${dids.length}`;
        allSlices.push({ label: shellLabel, dids });
      }

      const card = document.createElement('div');
      card.className = 'publish-card';

      const row = document.createElement('div');
      row.className = 'publish-card-row';

      const label = document.createElement('span');
      label.className = 'publish-card-label';
      label.textContent = 'all';

      const select = document.createElement('select');
      select.className = 'publish-select';
      for (let si = 0; si < allSlices.length; si++) {
        const opt = document.createElement('option');
        opt.value = si;
        opt.textContent = allSlices[si].label;
        if (si === allSlices.length - 1) opt.selected = true;
        select.appendChild(opt);
      }

      const btn = document.createElement('button');
      btn.className = 'publish-card-btn';
      btn.textContent = 'publish';

      const statusEl = document.createElement('div');
      statusEl.className = 'publish-card-status hidden';

      row.append(label, select, btn);
      card.append(row, statusEl);
      container.appendChild(card);

      btn.addEventListener('click', () => {
        const idx = parseInt(select.value);
        const dids = allSlices[idx].dids;
        publishList(dids, `All Clusters (${dids.length})`, btn, statusEl);
      });
    }
  }

  // --- Publish a list ---

  async function publishList(dids, listName, btn, statusEl) {
    const authHandle = document.getElementById('authHandle').value.trim().replace(/^@/, '');
    const authPassword = document.getElementById('authPassword').value;

    if (!authHandle || !authPassword) {
      statusEl.textContent = 'enter handle + app password above';
      statusEl.classList.remove('hidden');
      statusEl.classList.add('error');
      return;
    }

    btn.disabled = true;
    btn.textContent = 'publishing\u2026';
    statusEl.classList.remove('hidden', 'error');
    statusEl.textContent = 'authenticating\u2026';

    try {
      const did = await resolveHandle(authHandle);
      const pds = await resolvePDS(did);

      const sessionRes = await fetch(`${pds}/xrpc/com.atproto.server.createSession`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ identifier: authHandle, password: authPassword })
      });
      if (!sessionRes.ok) {
        const err = await sessionRes.json().catch(() => ({}));
        throw new Error(err.message || `Auth failed (${sessionRes.status})`);
      }
      const session = await sessionRes.json();
      const token = session.accessJwt;
      const repoDid = session.did;

      statusEl.textContent = 'creating list\u2026';
      const listRes = await fetch(`${pds}/xrpc/com.atproto.repo.createRecord`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          repo: repoDid,
          collection: 'app.bsky.graph.list',
          record: {
            $type: 'app.bsky.graph.list',
            purpose: 'app.bsky.graph.defs#curatelist',
            name: listName,
            description: `Mutual-follow cluster with shells, found by mino.mobi/cluster`,
            createdAt: new Date().toISOString()
          }
        })
      });
      if (!listRes.ok) throw new Error(`Failed to create list (${listRes.status})`);
      const { uri: listUri } = await listRes.json();

      for (let i = 0; i < dids.length; i++) {
        statusEl.textContent = `adding members\u2026 ${i + 1}/${dids.length}`;
        await fetch(`${pds}/xrpc/com.atproto.repo.createRecord`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            repo: repoDid,
            collection: 'app.bsky.graph.listitem',
            record: {
              $type: 'app.bsky.graph.listitem',
              subject: dids[i],
              list: listUri,
              createdAt: new Date().toISOString()
            }
          })
        });
      }

      const rkey = listUri.split('/').pop();
      const listUrl = `https://bsky.app/profile/${encodeURIComponent(authHandle)}/lists/${rkey}`;
      statusEl.innerHTML = `done \u00b7 ${dids.length} members \u00b7 <a href="${listUrl}" target="_blank" rel="noopener" style="color:var(--link)">view list</a>`;

    } catch (err) {
      statusEl.textContent = `error: ${err.message}`;
      statusEl.classList.add('error');
    } finally {
      btn.disabled = false;
      btn.textContent = 'publish';
    }
  }

  // --- Main ---

  let forceFullScan = false;

  document.getElementById('handleForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const raw = document.getElementById('handleInput').value.trim().replace(/^@/, '');
    if (!raw) return;

    const loadBtn = document.getElementById('loadBtn');
    const progressBar = document.getElementById('progressBar');
    const progressFill = document.getElementById('progressFill');
    const status = document.getElementById('status');
    const graphStats = document.getElementById('graphStats');

    loadBtn.disabled = true;
    loadBtn.textContent = 'scanning\u2026';
    progressBar.classList.remove('hidden');
    progressFill.style.width = '0%';
    status.classList.remove('hidden', 'error');
    status.textContent = 'resolving handle\u2026';
    graphStats.classList.add('hidden');
    document.getElementById('results').innerHTML = '';
    document.getElementById('graphContainer').innerHTML = '';
    document.getElementById('graphContainer').classList.add('hidden');
    document.getElementById('publishSection').classList.add('hidden');
    document.getElementById('rescanOffer').classList.add('hidden');
    document.getElementById('seekOffer').classList.add('hidden');
    document.getElementById('seekSection').classList.add('hidden');
    seekState = null;
    seekCandidates = [];

    const pageUrl = new URL(window.location);
    pageUrl.searchParams.set('handle', raw);
    window.history.replaceState({}, '', pageUrl);

    try {
      const did = await resolveHandle(raw);

      let usedFast = false;
      if (!forceFullScan) {
        usedFast = await fastPath(did, raw, status, progressFill, graphStats);
      }
      forceFullScan = false;

      if (!usedFast) {
        await fullPath(did, status, progressFill, graphStats);
      }

      if (currentCliques.some(c => c.core.length > 0)) {
        document.getElementById('authHandle').value = raw;
        document.getElementById('publishSection').classList.remove('hidden');
        buildPublishUI(currentCliques);
      }

    } catch (err) {
      status.textContent = `error: ${err.message}`;
      status.classList.add('error');
      progressFill.style.width = '0%';
    } finally {
      loadBtn.disabled = false;
      loadBtn.textContent = 'cluster';
    }
  });

  // Rescan button
  document.getElementById('rescanBtn').addEventListener('click', () => {
    forceFullScan = true;
    document.getElementById('handleForm').dispatchEvent(new Event('submit'));
  });

  // Seek button
  document.getElementById('seekBtn').addEventListener('click', async () => {
    const btn = document.getElementById('seekBtn');
    btn.disabled = true;
    btn.textContent = 'seeking\u2026';
    document.getElementById('seekSection').classList.remove('hidden');
    try {
      await runSeek();
    } catch (err) {
      const ss = document.getElementById('seekStatus');
      ss.classList.remove('hidden');
      ss.textContent = 'error: ' + err.message;
    } finally {
      btn.disabled = false;
      btn.textContent = 'seek';
    }
  });

  // Seek filter controls
  for (const id of ['seekMinCore', 'seekMaxFollows', 'seekMinFollowers', 'seekActive', 'seekSort']) {
    document.getElementById(id).addEventListener('input', () => {
      document.getElementById('seekMinCoreVal').textContent = document.getElementById('seekMinCore').value;
      const mf = parseInt(document.getElementById('seekMaxFollows').value);
      document.getElementById('seekMaxFollowsVal').textContent = fmtNum(mf);
      const fr = parseInt(document.getElementById('seekMinFollowers').value);
      document.getElementById('seekMinFollowersVal').textContent = fmtNum(fr);
      if (seekCandidates.length > 0) applySeekFilters();
    });
  }

  // Auto-load from URL
  const h = new URLSearchParams(location.search).get('handle');
  if (h) {
    document.getElementById('handleInput').value = h;
    document.getElementById('handleForm').dispatchEvent(new Event('submit'));
  }
})();
</script>

</body>
</html>
